//
// OCRIntegrationTests.swift
// FinanceMateTests
//
// Created by AI Agent on 2025-07-08.
// TASK-3.1.1.C: OCR-Transaction Integration - TDD Implementation
//

/*
 * Purpose: Comprehensive test suite for OCR-transaction integration workflows
 * Issues & Complexity Summary: End-to-end validation of OCR processing to transaction creation
 * Key Complexity Drivers:
   - Logic Scope (Est. LoC): ~600 (comprehensive integration testing)
   - Core Algorithm Complexity: High (fuzzy matching + learning algorithms)
   - Dependencies: OCR services, Core Data, transaction system, test data
   - State Management Complexity: High (multi-step workflow with learning)
   - Novelty/Uncertainty Factor: Medium (transaction matching patterns)
 * AI Pre-Task Self-Assessment: 90%
 * Problem Estimate: 92%
 * Initial Code Complexity Estimate: 94%
 * Final Code Complexity: TBD
 * Overall Result Score: TBD
 * Key Variances/Learnings: TDD approach for complex matching algorithms
 * Last Updated: 2025-07-08
 */

import XCTest
import CoreData
@testable import FinanceMate

final class OCRIntegrationTests: XCTestCase {
    
    // MARK: - Test Properties
    private var testContext: NSManagedObjectContext!
    private var transactionMatcher: OCRTransactionMatcher!
    private var suggestionEngine: TransactionSuggestionEngine!
    private var persistenceController: PersistenceController!
    
    // Test data
    private var realAustralianTransactions: [Transaction] = []
    private var realAustralianOCRResults: [VisionOCREngine.FinancialDocumentResult] = []
    
    // MARK: - Test Setup
    override func setUpWithError() throws {
        try super.setUpWithError()
        
        // Create in-memory Core Data stack for testing
        persistenceController = PersistenceController(inMemory: true)
        testContext = persistenceController.container.viewContext
        
        transactionMatcher = OCRTransactionMatcher(context: testContext)
        suggestionEngine = TransactionSuggestionEngine(context: testContext)
        
        // Create realAustralian test data
        try createSampleTransactions()
        createSampleOCRResults()
    }
    
    override func tearDownWithError() throws {
        // Clean up test data
        realAustralianTransactions.removeAll()
        realAustralianOCRResults.removeAll()
        
        transactionMatcher = nil
        suggestionEngine = nil
        testContext = nil
        persistenceController = nil
        
        try super.tearDownWithError()
    }
    
    // MARK: - Transaction Matching Tests
    
    func testExactTransactionMatching() async throws {
        // Given: OCR result that exactly matches existing transaction
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "WOOLWORTHS",
            totalAmount: 45.67,
            currency: "AUD",
            date: Calendar.current.date(byAdding: .day, value: -1, to: Date()),
            confidence: 0.95,
            recognizedText: "WOOLWORTHS RECEIPT"
        )
        
        // When: Finding matching transactions
        let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
        
        // Then: Should find exact match with high confidence
        XCTAssertFalse(matches.isEmpty, "Should find matching transactions")
        XCTAssertGreaterThan(matches.first?.confidence ?? 0.0, 0.9, "Exact match should have high confidence")
        XCTAssertEqual(matches.first?.transaction.amount, 45.67, "Amount should match exactly")
    }
    
    func testFuzzyMerchantNameMatching() async throws {
        // Given: OCR result with merchant name variation
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "WOOLWORTHS 1234", // Variation with store number
            totalAmount: 67.89,
            currency: "AUD",
            date: Calendar.current.date(byAdding: .day, value: -2, to: Date()),
            confidence: 0.92,
            recognizedText: "WOOLWORTHS 1234 RECEIPT"
        )
        
        // When: Finding matching transactions
        let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
        
        // Then: Should find fuzzy match
        XCTAssertFalse(matches.isEmpty, "Should find fuzzy matching transactions")
        XCTAssertGreaterThan(matches.first?.confidence ?? 0.0, 0.7, "Fuzzy match should have reasonable confidence")
        XCTAssertTrue(matches.first?.matchType == .fuzzyMerchant, "Should identify as fuzzy merchant match")
    }
    
    func testDateRangeMatching() async throws {
        // Given: OCR result with slightly different date
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "COLES",
            totalAmount: 123.45,
            currency: "AUD",
            date: Calendar.current.date(byAdding: .hour, value: -2, to: Date()),
            confidence: 0.90,
            recognizedText: "COLES SUPERMARKET"
        )
        
        // When: Finding matching transactions  
        let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
        
        // Then: Should find match within date tolerance
        XCTAssertFalse(matches.isEmpty, "Should find transactions within date range")
        XCTAssertGreaterThan(matches.first?.confidence ?? 0.0, 0.8, "Date range match should have good confidence")
    }
    
    func testNoMatchingTransactions() async throws {
        // Given: OCR result with no existing matches
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "UNKNOWN MERCHANT",
            totalAmount: 999.99,
            currency: "AUD",
            date: Calendar.current.date(byAdding: .day, value: -30, to: Date()),
            confidence: 0.85,
            recognizedText: "UNKNOWN MERCHANT RECEIPT"
        )
        
        // When: Finding matching transactions
        let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
        
        // Then: Should return empty results
        XCTAssertTrue(matches.isEmpty, "Should not find matches for unknown merchant")
    }
    
    func testPerformanceWithLargeDataset() async throws {
        // Given: Large number of historical transactions
        try await createLargeTransactionDataset(count: 1000)
        
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "PERFORMANCE TEST",
            totalAmount: 50.00,
            currency: "AUD",
            date: Date(),
            confidence: 0.90,
            recognizedText: "PERFORMANCE TEST RECEIPT"
        )
        
        // When: Finding matches with performance measurement
        let startTime = CFAbsoluteTimeGetCurrent()
        let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
        let endTime = CFAbsoluteTimeGetCurrent()
        
        // Then: Should complete within performance target
        let processingTime = endTime - startTime
        XCTAssertLessThan(processingTime, 0.5, "Matching should complete within 500ms for 1000 transactions")
    }
    
    // MARK: - Transaction Suggestion Tests
    
    func testCategorySuggestionForGroceries() async throws {
        // Given: OCR result from grocery store
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "WOOLWORTHS",
            totalAmount: 78.90,
            currency: "AUD",
            date: Date(),
            confidence: 0.95,
            recognizedText: "WOOLWORTHS SUPERMARKET"
        )
        
        // When: Getting category suggestions
        let suggestions = try await suggestionEngine.suggestCategories(for: ocrResult)
        
        // Then: Should suggest grocery-related categories
        XCTAssertFalse(suggestions.isEmpty, "Should provide category suggestions")
        XCTAssertTrue(suggestions.contains { $0.category.contains("Groceries") || $0.category.contains("Food") }, 
                     "Should suggest grocery categories")
        XCTAssertGreaterThan(suggestions.first?.confidence ?? 0.0, 0.7, "Suggestions should have reasonable confidence")
    }
    
    func testCategorySuggestionForHardware() async throws {
        // Given: OCR result from hardware store
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "BUNNINGS WAREHOUSE",
            totalAmount: 156.78,
            currency: "AUD",
            date: Date(),
            confidence: 0.92,
            recognizedText: "BUNNINGS WAREHOUSE"
        )
        
        // When: Getting category suggestions
        let suggestions = try await suggestionEngine.suggestCategories(for: ocrResult)
        
        // Then: Should suggest hardware/home improvement categories
        XCTAssertFalse(suggestions.isEmpty, "Should provide category suggestions")
        XCTAssertTrue(suggestions.contains { $0.category.contains("Home") || $0.category.contains("Hardware") }, 
                     "Should suggest hardware categories")
    }
    
    func testSplitAllocationSuggestions() async throws {
        // Given: Business-related OCR result
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "OFFICEWORKS",
            totalAmount: 89.95,
            currency: "AUD",
            date: Date(),
            gstAmount: 8.18,
            isValidABN: true,
            confidence: 0.94,
            recognizedText: "OFFICEWORKS BUSINESS SUPPLIES"
        )
        
        // When: Getting split allocation suggestions
        let splitSuggestions = try await suggestionEngine.suggestSplitAllocations(for: ocrResult)
        
        // Then: Should suggest business/personal split
        XCTAssertFalse(splitSuggestions.isEmpty, "Should provide split suggestions")
        XCTAssertTrue(splitSuggestions.contains { $0.category == "Business" }, "Should suggest business allocation")
        XCTAssertTrue(splitSuggestions.first?.percentage ?? 0.0 > 0.0, "Should have valid percentage allocation")
    }
    
    func testLearningFromUserCorrections() async throws {
        // Given: Initial category suggestion
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "NEW MERCHANT",
            totalAmount: 25.00,
            currency: "AUD",
            date: Date(),
            confidence: 0.85,
            recognizedText: "NEW MERCHANT RECEIPT"
        )
        
        let initialSuggestions = try await suggestionEngine.suggestCategories(for: ocrResult)
        
        // When: User corrects the suggestion
        let userCorrection = TransactionSuggestionEngine.UserCorrection(
            merchantName: "NEW MERCHANT",
            originalCategory: initialSuggestions.first?.category ?? "General",
            correctedCategory: "Entertainment",
            confidence: 1.0
        )
        
        try await suggestionEngine.recordUserCorrection(userCorrection)
        
        // Then: Future suggestions should learn from correction
        let improvedSuggestions = try await suggestionEngine.suggestCategories(for: ocrResult)
        XCTAssertTrue(improvedSuggestions.contains { $0.category == "Entertainment" }, 
                     "Should learn from user correction")
        XCTAssertGreaterThan(improvedSuggestions.first { $0.category == "Entertainment" }?.confidence ?? 0.0, 
                           initialSuggestions.first?.confidence ?? 0.0, 
                           "Learning should improve confidence for corrected category")
    }
    
    // MARK: - End-to-End Integration Tests
    
    func testCompleteOCRToTransactionWorkflow() async throws {
        // Given: Complete OCR result
        let ocrResult = VisionOCREngine.FinancialDocumentResult(
            merchantName: "KMART",
            totalAmount: 34.99,
            currency: "AUD",
            date: Date(),
            gstAmount: 3.18,
            confidence: 0.93,
            recognizedText: "KMART STORE RECEIPT"
        )
        
        // When: Complete workflow execution
        let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
        let suggestions = try await suggestionEngine.suggestCategories(for: ocrResult)
        let splitSuggestions = try await suggestionEngine.suggestSplitAllocations(for: ocrResult)
        
        // Create new transaction from OCR result
        let newTransaction = Transaction(context: testContext)
        newTransaction.id = UUID()
        newTransaction.amount = ocrResult.totalAmount ?? 0.0
        newTransaction.date = ocrResult.date ?? Date()
        newTransaction.note = ocrResult.merchantName ?? "Unknown"
        newTransaction.category = suggestions.first?.category ?? "General"
        newTransaction.createdAt = Date()
        
        try testContext.save()
        
        // Then: Complete workflow should succeed
        XCTAssertNotNil(newTransaction.id, "Transaction should be created successfully")
        XCTAssertEqual(newTransaction.amount, 34.99, "Transaction amount should match OCR result")
        XCTAssertNotNil(suggestions.first?.category, "Should provide category suggestions")
        XCTAssertFalse(splitSuggestions.isEmpty, "Should provide split allocation suggestions")
    }
    
    func testBatchProcessingMultipleReceipts() async throws {
        // Given: Multiple OCR results for batch processing
        let ocrResults = [
            VisionOCREngine.FinancialDocumentResult(
                merchantName: "WOOLWORTHS", totalAmount: 45.67, currency: "AUD", date: Date(), confidence: 0.95
            ),
            VisionOCREngine.FinancialDocumentResult(
                merchantName: "COLES", totalAmount: 67.89, currency: "AUD", date: Date(), confidence: 0.92
            ),
            VisionOCREngine.FinancialDocumentResult(
                merchantName: "BUNNINGS", totalAmount: 123.45, currency: "AUD", date: Date(), confidence: 0.90
            )
        ]
        
        // When: Processing multiple receipts
        var processedResults: [(matches: [OCRTransactionMatcher.TransactionMatch], suggestions: [TransactionSuggestionEngine.CategorySuggestion])] = []
        
        for ocrResult in ocrResults {
            let matches = try await transactionMatcher.findMatchingTransactions(for: ocrResult)
            let suggestions = try await suggestionEngine.suggestCategories(for: ocrResult)
            processedResults.append((matches: matches, suggestions: suggestions))
        }
        
        // Then: All receipts should be processed successfully
        XCTAssertEqual(processedResults.count, 3, "Should process all receipts")
        XCTAssertTrue(processedResults.allSatisfy { !$0.suggestions.isEmpty }, "All receipts should have suggestions")
    }
    
    // MARK: - Helper Methods
    
    private func createSampleTransactions() throws {
        let calendar = Calendar.current
        
        // Create transactions for testing matching
        let transactions = [
            ("WOOLWORTHS", 45.67, calendar.date(byAdding: .day, value: -1, to: Date())!),
            ("COLES", 67.89, calendar.date(byAdding: .day, value: -2, to: Date())!),
            ("BUNNINGS", 123.45, calendar.date(byAdding: .day, value: -3, to: Date())!),
            ("KMART", 34.99, calendar.date(byAdding: .day, value: -4, to: Date())!),
            ("JB HI-FI", 299.99, calendar.date(byAdding: .day, value: -5, to: Date())!)
        ]
        
        for (merchant, amount, date) in transactions {
            let transaction = Transaction(context: testContext)
            transaction.id = UUID()
            transaction.amount = amount
            transaction.date = date
            transaction.note = merchant
            transaction.category = "General"
            transaction.createdAt = Date()
            realAustralianTransactions.append(transaction)
        }
        
        try testContext.save()
    }
    
    private func createSampleOCRResults() {
        realAustralianOCRResults = [
            VisionOCREngine.FinancialDocumentResult(
                merchantName: "WOOLWORTHS",
                totalAmount: 45.67,
                currency: "AUD",
                date: Calendar.current.date(byAdding: .day, value: -1, to: Date()),
                confidence: 0.95,
                recognizedText: "WOOLWORTHS SUPERMARKET RECEIPT"
            ),
            VisionOCREngine.FinancialDocumentResult(
                merchantName: "COLES 1234",
                totalAmount: 67.89,
                currency: "AUD",
                date: Calendar.current.date(byAdding: .day, value: -2, to: Date()),
                confidence: 0.92,
                recognizedText: "COLES SUPERMARKET 1234"
            )
        ]
    }
    
    private func createLargeTransactionDataset(count: Int) async throws {
        let merchants = ["WOOLWORTHS", "COLES", "BUNNINGS", "KMART", "TARGET", "MYER", "JB HI-FI"]
        let calendar = Calendar.current
        
        for i in 0..<count {
            let transaction = Transaction(context: testContext)
            transaction.id = UUID()
            transaction.amount = Double.random(in: 10.0...500.0)
            transaction.date = calendar.date(byAdding: .day, value: -i, to: Date()) ?? Date()
            transaction.note = merchants.randomElement() ?? "MERCHANT"
            transaction.category = "General"
            transaction.createdAt = Date()
        }
        
        try testContext.save()
    }
}