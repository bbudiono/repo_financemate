// SANDBOX FILE: For testing/development. See .cursorrules.

import Combine
import XCTest

@testable import FinanceMate_Sandbox

// Simple keychain for testing
class TestKeychain {
  private var storage: [String: String] = [:]

  func set(_ value: String, forKey key: String) {
    storage[key] = value
  }

  func get(_ key: String) -> String? {
    return storage[key]
  }

  func delete(_ key: String) {
    storage.removeValue(forKey: key)
  }

  func clear() {
    storage.removeAll()
  }
}

/*
 * Purpose: Comprehensive test suite for Basiq API integration - Australian banking connectivity
 * Issues & Complexity Summary: Complex async API testing, mock network responses, secure credential testing
 * Key Complexity Drivers:
   - Logic Scope (Est. LoC): ~600
   - Core Algorithm Complexity: High (Async testing, network mocking, OAuth flow)
   - Dependencies: XCTest, Combine, URLSession mocking
   - State Management Complexity: High (Authentication states, connection flows)
   - Novelty/Uncertainty Factor: Medium (API testing patterns)
 * AI Pre-Task Self-Assessment: 85%
 * Problem Estimate: 82%
 * Initial Code Complexity Estimate: 80%
 * Final Code Complexity: TBD
 * Overall Result Score: TBD
 * Key Variances/Learnings: TBD
 * Last Updated: 2025-08-08
 */

@MainActor
final class BasiqAPIServiceTests: XCTestCase {

  var basiqService: BasiqAPIService!
  var cancellables: Set<AnyCancellable>!

  override func setUp() {
    super.setUp()
    basiqService = BasiqAPIService()
    cancellables = Set<AnyCancellable>()

    // Clear any existing keychain data for clean tests
    clearKeychainForTesting()
  }

  override func tearDown() {
    clearKeychainForTesting()
    cancellables = nil
    basiqService = nil
    super.tearDown()
  }

  // MARK: - Authentication Tests

  func testInitialAuthenticationState() {
    // Given: Fresh service instance
    // When: Service is initialized
    // Then: Should not be authenticated initially
    XCTAssertFalse(basiqService.isAuthenticated)
    XCTAssertEqual(basiqService.connectionStatus, .disconnected)
    XCTAssertTrue(basiqService.availableInstitutions.isEmpty)
    XCTAssertTrue(basiqService.userConnections.isEmpty)
  }

  func testAuthenticationWithValidCredentials() async {
    // Given: Valid credentials configured
    setMockCredentials()

    // Mock successful authentication response
    mockURLSessionResponse(
      data: mockAuthResponse(),
      statusCode: 200
    )

    // When: Authenticate is called
    do {
      try await basiqService.authenticate()

      // Then: Service should be authenticated
      XCTAssertTrue(basiqService.isAuthenticated)
      XCTAssertEqual(basiqService.connectionStatus, .connected)
      XCTAssertNil(basiqService.errorMessage)
    } catch {
      XCTFail("Authentication should succeed with valid credentials: \(error)")
    }
  }

  func testAuthenticationWithInvalidCredentials() async {
    // Given: Invalid credentials
    setMockCredentials()

    // Mock authentication failure response
    mockURLSessionResponse(
      data: mockErrorResponse(),
      statusCode: 401
    )

    // When: Authenticate is called
    do {
      try await basiqService.authenticate()
      XCTFail("Authentication should fail with invalid credentials")
    } catch {
      // Then: Authentication should fail
      XCTAssertFalse(basiqService.isAuthenticated)
      XCTAssertEqual(basiqService.connectionStatus, .error("Invalid credentials"))
      XCTAssertNotNil(basiqService.errorMessage)
    }
  }

  func testAuthenticationWithMissingCredentials() async {
    // Given: No credentials configured
    // When: Authenticate is called
    do {
      try await basiqService.authenticate()
      XCTFail("Authentication should fail with missing credentials")
    } catch let error as BasiqAPIError {
      // Then: Should throw missing credentials error
      XCTAssertEqual(error, .missingCredentials)
      XCTAssertFalse(basiqService.isAuthenticated)
    } catch {
      XCTFail("Unexpected error type: \(error)")
    }
  }

  // MARK: - Institution Tests

  func testFetchInstitutionsSuccess() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock institutions response
    mockURLSessionResponse(
      data: mockInstitutionsResponse(),
      statusCode: 200
    )

    // When: Fetch institutions is called
    do {
      try await basiqService.fetchInstitutions()

      // Then: Should populate institutions
      XCTAssertFalse(basiqService.availableInstitutions.isEmpty)
      XCTAssertEqual(basiqService.connectionStatus, .connected)

      // Verify institution data structure
      let firstInstitution = basiqService.availableInstitutions.first!
      XCTAssertEqual(firstInstitution.country, "AU")
      XCTAssertFalse(firstInstitution.name.isEmpty)
      XCTAssertFalse(firstInstitution.shortName.isEmpty)
    } catch {
      XCTFail("Fetch institutions should succeed: \(error)")
    }
  }

  func testFetchInstitutionsWithoutAuthentication() async {
    // Given: Unauthenticated service
    // When: Fetch institutions is called
    do {
      try await basiqService.fetchInstitutions()
      XCTFail("Should fail without authentication")
    } catch let error as BasiqAPIError {
      // Then: Should throw not authenticated error
      XCTAssertEqual(error, .notAuthenticated)
    } catch {
      XCTFail("Unexpected error type: \(error)")
    }
  }

  // MARK: - Connection Tests

  func testCreateConnectionSuccess() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock successful connection response
    mockURLSessionResponse(
      data: mockConnectionResponse(),
      statusCode: 201
    )

    // When: Create connection is called
    do {
      let connectionId = try await basiqService.createConnection(
        institutionId: "AU00000",
        loginId: "testuser",
        password: "testpass"
      )

      // Then: Should return connection ID
      XCTAssertFalse(connectionId.isEmpty)
      XCTAssertFalse(basiqService.isConnecting)
      XCTAssertEqual(basiqService.connectionStatus, .connected)
    } catch {
      XCTFail("Create connection should succeed: \(error)")
    }
  }

  func testCreateConnectionWithInvalidCredentials() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock connection failure response
    mockURLSessionResponse(
      data: mockErrorResponse(),
      statusCode: 400
    )

    // When: Create connection with invalid credentials
    do {
      _ = try await basiqService.createConnection(
        institutionId: "AU00000",
        loginId: "invalid",
        password: "invalid"
      )
      XCTFail("Should fail with invalid credentials")
    } catch let error as BasiqAPIError {
      // Then: Should throw connection failed error
      if case .connectionFailed = error {
        XCTAssertFalse(basiqService.isConnecting)
        XCTAssertNotNil(basiqService.errorMessage)
      } else {
        XCTFail("Expected connectionFailed error")
      }
    } catch {
      XCTFail("Unexpected error type: \(error)")
    }
  }

  func testFetchConnections() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock connections response
    mockURLSessionResponse(
      data: mockConnectionsResponse(),
      statusCode: 200
    )

    // When: Fetch connections is called
    do {
      try await basiqService.fetchConnections()

      // Then: Should populate connections
      XCTAssertFalse(basiqService.userConnections.isEmpty)

      let connection = basiqService.userConnections.first!
      XCTAssertFalse(connection.id.isEmpty)
      XCTAssertFalse(connection.institution.name.isEmpty)
    } catch {
      XCTFail("Fetch connections should succeed: \(error)")
    }
  }

  // MARK: - Transaction Tests

  func testFetchTransactionsSuccess() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock transactions response
    mockURLSessionResponse(
      data: mockTransactionsResponse(),
      statusCode: 200
    )

    // When: Fetch transactions is called
    do {
      let transactions = try await basiqService.fetchTransactions(for: "test-connection-id")

      // Then: Should return transactions
      XCTAssertFalse(transactions.isEmpty)
      XCTAssertEqual(basiqService.connectionStatus, .connected)
      XCTAssertNotNil(basiqService.lastSyncDate)

      let transaction = transactions.first!
      XCTAssertFalse(transaction.id.isEmpty)
      XCTAssertFalse(transaction.description.isEmpty)
      XCTAssertFalse(transaction.amount.isEmpty)
    } catch {
      XCTFail("Fetch transactions should succeed: \(error)")
    }
  }

  func testFetchTransactionsWithLimit() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock transactions response with specific limit
    mockURLSessionResponse(
      data: mockTransactionsResponse(count: 100),
      statusCode: 200
    )

    // When: Fetch transactions with limit
    do {
      let transactions = try await basiqService.fetchTransactions(
        for: "test-connection-id", limit: 100)

      // Then: Should respect the limit
      XCTAssertEqual(transactions.count, 100)
    } catch {
      XCTFail("Fetch transactions with limit should succeed: \(error)")
    }
  }

  // MARK: - Background Sync Tests

  func testBackgroundSyncWithAuthentication() async {
    // Given: Authenticated service with connections
    await authenticateService()
    await setupMockConnections()

    // Mock sync responses
    mockURLSessionResponse(
      data: mockTransactionsResponse(),
      statusCode: 200
    )

    // When: Background sync is performed
    await basiqService.performBackgroundSync()

    // Then: Should complete without errors
    XCTAssertNil(basiqService.errorMessage)
    XCTAssertNotNil(basiqService.lastSyncDate)
  }

  func testBackgroundSyncWithoutAuthentication() async {
    // Given: Unauthenticated service
    // When: Background sync is performed
    await basiqService.performBackgroundSync()

    // Then: Should attempt authentication first
    // This test verifies the service attempts to authenticate when not authenticated
    XCTAssertTrue(true)  // Basic completion test
  }

  // MARK: - Error Handling Tests

  func testNetworkErrorHandling() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock network error
    mockURLSessionError(NSError(domain: NSURLErrorDomain, code: NSURLErrorNotConnectedToInternet))

    // When: API call is made
    do {
      try await basiqService.fetchInstitutions()
      XCTFail("Should fail with network error")
    } catch {
      // Then: Should handle network error gracefully
      XCTAssertNotNil(basiqService.errorMessage)
    }
  }

  func testInvalidResponseHandling() async {
    // Given: Authenticated service
    await authenticateService()

    // Mock invalid JSON response
    mockURLSessionResponse(
      data: "Invalid JSON".data(using: .utf8)!,
      statusCode: 200
    )

    // When: API call is made
    do {
      try await basiqService.fetchInstitutions()
      XCTFail("Should fail with invalid response")
    } catch {
      // Then: Should handle parsing error
      XCTAssertNotNil(basiqService.errorMessage)
    }
  }

  // MARK: - Performance Tests

  func testAuthenticationPerformance() {
    setMockCredentials()
    mockURLSessionResponse(data: mockAuthResponse(), statusCode: 200)

    measure {
      let expectation = expectation(description: "Authentication performance")

      Task {
        do {
          try await basiqService.authenticate()
          expectation.fulfill()
        } catch {
          XCTFail("Authentication failed: \(error)")
        }
      }

      waitForExpectations(timeout: 5.0)
    }
  }

  func testLargeTransactionsFetchPerformance() {
    measure {
      let expectation = expectation(description: "Large transactions fetch")

      Task {
        await authenticateService()
        mockURLSessionResponse(data: mockTransactionsResponse(count: 1000), statusCode: 200)

        do {
          let transactions = try await basiqService.fetchTransactions(for: "test-id", limit: 1000)
          XCTAssertEqual(transactions.count, 1000)
          expectation.fulfill()
        } catch {
          XCTFail("Large fetch failed: \(error)")
        }
      }

      waitForExpectations(timeout: 10.0)
    }
  }

  // MARK: - Integration Tests

  func testCompleteConnectionFlow() async {
    // Given: Fresh service
    setMockCredentials()

    // Mock all required responses
    mockURLSessionResponse(data: mockAuthResponse(), statusCode: 200)

    do {
      // When: Complete flow is executed
      try await basiqService.authenticate()

      mockURLSessionResponse(data: mockInstitutionsResponse(), statusCode: 200)
      try await basiqService.fetchInstitutions()

      mockURLSessionResponse(data: mockConnectionResponse(), statusCode: 201)
      let connectionId = try await basiqService.createConnection(
        institutionId: "AU00000",
        loginId: "test",
        password: "test"
      )

      mockURLSessionResponse(data: mockTransactionsResponse(), statusCode: 200)
      let transactions = try await basiqService.fetchTransactions(for: connectionId)

      // Then: All steps should succeed
      XCTAssertTrue(basiqService.isAuthenticated)
      XCTAssertFalse(basiqService.availableInstitutions.isEmpty)
      XCTAssertFalse(connectionId.isEmpty)
      XCTAssertFalse(transactions.isEmpty)

    } catch {
      XCTFail("Complete flow should succeed: \(error)")
    }
  }

  // MARK: - Helper Methods

  private func clearKeychainForTesting() {
    UserDefaults.standard.removeObject(forKey: "keychain_basiq_access_token")
    UserDefaults.standard.removeObject(forKey: "keychain_basiq_refresh_token")
    UserDefaults.standard.removeObject(forKey: "keychain_basiq_token_expiry")
  }

  private func setMockCredentials() {
    // Set environment variables for testing
    setenv("BASIQ_CLIENT_ID", "test_client_id", 1)
    setenv("BASIQ_CLIENT_SECRET", "test_client_secret", 1)
  }

  private func authenticateService() async {
    setMockCredentials()
    mockURLSessionResponse(data: mockAuthResponse(), statusCode: 200)
    try? await basiqService.authenticate()
  }

  private func setupMockConnections() async {
    mockURLSessionResponse(data: mockConnectionsResponse(), statusCode: 200)
    try? await basiqService.fetchConnections()
  }

  // MARK: - Mock Data

  private func mockAuthResponse() -> Data {
    let response = """
      {
          "access_token": "test_access_token_12345",
          "token_type": "Bearer",
          "expires_in": 3600
      }
      """
    return response.data(using: .utf8)!
  }

  private func mockInstitutionsResponse() -> Data {
    let response = """
      {
          "data": [
              {
                  "id": "AU00000",
                  "name": "Commonwealth Bank of Australia",
                  "shortName": "CBA",
                  "institutionType": "bank",
                  "country": "AU",
                  "serviceName": "CommBank",
                  "serviceType": "personal",
                  "loginIdCaption": "Client Number",
                  "passwordCaption": "Password",
                  "tier": "1",
                  "authorization": {
                      "adr": true,
                      "credentials": []
                  }
              }
          ]
      }
      """
    return response.data(using: .utf8)!
  }

  private func mockConnectionResponse() -> Data {
    let response = """
      {
          "id": "test_connection_12345"
      }
      """
    return response.data(using: .utf8)!
  }

  private func mockConnectionsResponse() -> Data {
    let response = """
      {
          "data": [
              {
                  "id": "test_connection_12345",
                  "status": "active",
                  "lastUsed": "2025-08-08T09:00:00Z",
                  "institution": {
                      "id": "AU00000",
                      "name": "Commonwealth Bank of Australia",
                      "shortName": "CBA",
                      "institutionType": "bank",
                      "country": "AU",
                      "serviceName": "CommBank",
                      "serviceType": "personal",
                      "loginIdCaption": "Client Number",
                      "passwordCaption": "Password",
                      "tier": "1",
                      "authorization": {
                          "adr": true,
                          "credentials": []
                      }
                  }
              }
          ]
      }
      """
    return response.data(using: .utf8)!
  }

  private func mockTransactionsResponse(count: Int = 5) -> Data {
    let transactions = (1...count).map { i in
      """
      {
          "id": "txn_\(i)",
          "status": "posted",
          "description": "Test Transaction \(i)",
          "amount": "-\(i * 10).00",
          "account": "acc_123",
          "direction": "debit",
          "class": "payment",
          "institution": "AU00000",
          "connection": "test_connection_12345",
          "postDate": "2025-08-08",
          "transactionDate": "2025-08-08"
      }
      """
    }.joined(separator: ",")

    let response = """
      {
          "data": [\(transactions)]
      }
      """
    return response.data(using: .utf8)!
  }

  private func mockErrorResponse() -> Data {
    let response = """
      {
          "correlationId": "test_correlation_123",
          "data": [
              {
                  "code": "invalid_credentials",
                  "title": "Invalid Credentials",
                  "detail": "The provided credentials are invalid"
              }
          ]
      }
      """
    return response.data(using: .utf8)!
  }

  // MARK: - Mock URL Session

  private func mockURLSessionResponse(data: Data, statusCode: Int) {
    // This would require URL session mocking implementation
    // For now, this is a placeholder for the mocking infrastructure
  }

  private func mockURLSessionError(_ error: Error) {
    // This would require URL session mocking implementation
    // For now, this is a placeholder for the mocking infrastructure
  }
}

// MARK: - Basiq API Error Equatable

extension BasiqAPIError: Equatable {
  public static func == (lhs: BasiqAPIError, rhs: BasiqAPIError) -> Bool {
    switch (lhs, rhs) {
    case (.missingCredentials, .missingCredentials):
      return true
    case (.notAuthenticated, .notAuthenticated):
      return true
    case (.invalidResponse, .invalidResponse):
      return true
    case (.authenticationFailed(let lhsMessage), .authenticationFailed(let rhsMessage)):
      return lhsMessage == rhsMessage
    case (.connectionFailed(let lhsMessage), .connectionFailed(let rhsMessage)):
      return lhsMessage == rhsMessage
    case (.requestFailed(let lhsMessage), .requestFailed(let rhsMessage)):
      return lhsMessage == rhsMessage
    default:
      return false
    }
  }
}
