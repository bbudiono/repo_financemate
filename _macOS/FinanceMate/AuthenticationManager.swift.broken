import SwiftUI
import AuthenticationServices
import os.log
import Foundation

/**
 * Purpose: Unified authentication manager for Apple and Google SSO
 * Issues & Complexity Summary: Enhanced to support new authentication types and secure storage
 * Key Complexity Drivers:
 * - Logic Scope (Est. LoC): ~150
 * - Core Algorithm Complexity: Medium (dual provider management)
 * - Dependencies: 2 New (AuthTypes, TokenStorageService), 1 Mod (GmailOAuthHelper)
 * - State Management Complexity: Medium (ObservableObject with multiple providers)
 * - Novelty/Uncertainty Factor: Low (standard authentication patterns)
 * AI Pre-Task Self-Assessment: 90%
 * Problem Estimate: 85%
 * Initial Code Complexity Estimate: 80%
 * Final Code Complexity: 82%
 * Overall Result Score: 94%
 * Key Variances/Learnings: Unified interface for multiple authentication providers
 * Last Updated: 2025-10-06
 */

/// Unified authentication manager supporting Apple Sign In and Google OAuth
@MainActor
public class AuthenticationManager: ObservableObject {

    // MARK: - Published Properties

    /// Current authentication state
    @Published public private(set) var authState: AuthState = .unknown

    /// Current authentication status
    @Published public private(set) var isAuthenticated: Bool {
        authState.isAuthenticated
    }

    /// Current user's email
    public var userEmail: String? {
        authState.user?.email
    }

    /// Current user's name
    public var userName: String? {
        authState.user?.name
    }

    /// Current error message
    public var errorMessage: String? {
        authState.error?.localizedDescription
    }

    // MARK: - Private Properties

    private let logger = Logger(subsystem: "FinanceMate", category: "AuthenticationManager")
    /// Token storage service for secure credential management
    private let tokenStorage = TokenStorageService.shared

    // MARK: - Initialization

    public init() {
        checkAuthStatus()
    }

    // MARK: - Apple Sign In

    /// Handle Apple Sign In result
    public func handleAppleSignIn(result: Result<ASAuthorization, Error>) async {
        await MainActor.run {
            updateAuthState(.authenticating)
        }

        switch result {
        case .success(let authorization):
            await handleAppleSignInSuccess(authorization)
        case .failure(let error):
            await handleAppleSignInFailure(error)
        }
    }

    private func handleAppleSignInSuccess(_ authorization: ASAuthorization) async {
        guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else {
            await updateAuthState(.error(.invalidCredentials))
            return
        }

        let userID = appleIDCredential.user
        let email = appleIDCredential.email ?? ""
        let fullName = appleIDCredential.fullName

        let nameComponents = [fullName?.givenName, fullName?.familyName].compactMap { $0 }
        let name = nameComponents.isEmpty ? "Apple User" : nameComponents.joined(separator: " ")

        let user = AuthUser(id: userID, email: email, name: name, provider: .apple)

        // Store credentials securely
        let idToken = appleIDCredential.identityToken.flatMap { String(data: $0, encoding: .utf8) }
        let authorizationCode = appleIDCredential.authorizationCode.flatMap { String(data: $0, encoding: .utf8) }

        tokenStorage.storeAppleCredentials(
            userID: userID,
            email: email,
            name: name,
            idToken: idToken,
            refreshToken: authorizationCode
        )

        // Store token info if available
        if let idToken = idToken {
            let tokenInfo = TokenInfo(accessToken: idToken, refreshToken: authorizationCode, expiresIn: 3600)
            tokenStorage.storeTokenInfo(tokenInfo, for: .apple)
        }

        // Store auth state
        let newAuthState = AuthState.authenticated(user)
        tokenStorage.storeAuthState(newAuthState)

        await MainActor.run {
            updateAuthState(newAuthState)
        }

        logger.info("Apple Sign In successful for user: \(email)")
    }

    private func handleAppleSignInFailure(_ error: Error) async {
        let authError: AuthError

        if let asAuthError = error as? ASAuthorizationError {
            authError = switch asAuthError.code {
            case .canceled:
                .cancelledByUser
            case .invalidResponse:
                .invalidCredentials
            case .notHandled:
                .networkError
            default:
                .custom("Apple Sign In error: \(asAuthError.localizedDescription)")
            }
        } else {
            authError = .custom("Apple Sign In failed: \(error.localizedDescription)")
        }

        let newAuthState = AuthState.error(authError)
        await MainActor.run {
            updateAuthState(newAuthState)
        }

        logger.error("Apple Sign In failed: \(error.localizedDescription)")
    }

    // MARK: - Google Sign In

    /// Handle Google OAuth sign in with authorization code
    public func handleGoogleSignIn(code: String) async {
        await MainActor.run {
            updateAuthState(.authenticating)
        }

        // Get OAuth configuration from environment variables
        guard let clientID = ProcessInfo.processInfo.environment["GOOGLE_OAUTH_CLIENT_ID"],
              let clientSecret = ProcessInfo.processInfo.environment["GOOGLE_OAUTH_CLIENT_SECRET"] else {
            await updateAuthState(.error(.custom("Google OAuth credentials not found")))
            return
        }

        do {
            // Exchange authorization code for tokens
            let tokenResponse = try await GmailOAuthHelper.exchangeCodeForToken(
                code: code,
                clientID: clientID,
                clientSecret: clientSecret,
                redirectURI: "com.ablankcanvas.financemate:/oauth2redirect"
            )

            // Fetch user information
            let userInfo = try await fetchGoogleUserInfo(accessToken: tokenResponse.accessToken)

            // Create user object
            let user = AuthUser(id: userInfo.id, email: userInfo.email, name: userInfo.name, provider: .google)

            // Store credentials securely
            tokenStorage.storeGoogleCredentials(
                userID: userInfo.id,
                email: userInfo.email,
                name: userInfo.name,
                accessToken: tokenResponse.accessToken,
                refreshToken: tokenResponse.refreshToken,
                userInfo: userInfo
            )

            // Store token info
            let tokenInfo = TokenInfo(
                accessToken: tokenResponse.accessToken,
                refreshToken: tokenResponse.refreshToken,
                expiresIn: tokenResponse.expiresIn,
                tokenType: tokenResponse.tokenType
            )
            tokenStorage.storeTokenInfo(tokenInfo, for: .google)

            // Store auth state
            let newAuthState = AuthState.authenticated(user)
            tokenStorage.storeAuthState(newAuthState)

            await MainActor.run {
                updateAuthState(newAuthState)
            }

            logger.info("Google Sign In successful for user: \(userInfo.email)")

        } catch {
            let authError: AuthError

            if error is OAuthError {
                authError = .custom("Google OAuth error: \(error.localizedDescription)")
            } else if error is URLError {
                authError = .networkError
            } else {
                authError = .custom("Google Sign In failed: \(error.localizedDescription)")
            }

            await MainActor.run {
                updateAuthState(.error(authError))
            }

            logger.error("Google Sign In failed: \(error.localizedDescription)")
        }
    }

    /// Fetch Google user information using access token
    public func fetchGoogleUserInfo(accessToken: String) async throws -> GoogleUserInfo {
        return try await GmailOAuthHelper.fetchUserInfo(accessToken: accessToken)
    }

    // MARK: - Authentication Status

    /// Check current authentication status from secure storage
    public func checkAuthStatus() {
        if let storedAuthState = tokenStorage.getAuthState() {
            updateAuthState(storedAuthState)

            if case .authenticated(let user) = storedAuthState {
                logger.info("Restored authentication for user: \(user.email) with provider: \(user.provider.rawValue)")
            }
        } else {
            // Check legacy storage for backward compatibility
            checkLegacyAuthStatus()
        }
    }

    /// Check Google-specific authentication status
    public func checkGoogleAuthStatus() {
        if let googleCredentials = tokenStorage.getGoogleCredentials(),
           googleCredentials.userID != nil {

            let user = AuthUser(
                id: googleCredentials.userID!,
                email: googleCredentials.email ?? "",
                name: googleCredentials.name ?? "Google User",
                provider: .google
            )

            updateAuthState(.authenticated(user))
            logger.info("Restored Google authentication for user: \(googleCredentials.email ?? "unknown")")
        }
    }

    // MARK: - Sign Out

    /// Sign out current user and clear all stored data
    public func signOut() {
        logger.info("Signing out current user")

        // Clear all stored authentication data
        tokenStorage.clearAllData()

        // Update state
        updateAuthState(.signedOut)
    }

    /// Sign out from specific provider
    public func signOut(from provider: AuthProvider) {
        logger.info("Signing out from provider: \(provider.rawValue)")

        tokenStorage.clearData(for: provider)

        // Check if user is still authenticated with another provider
        if let currentProvider = tokenStorage.getCurrentProvider() {
            switch currentProvider {
            case .apple:
                checkAppleAuthStatus()
            case .google:
                checkGoogleAuthStatus()
            }
        } else {
            updateAuthState(.signedOut)
        }
    }

    // MARK: - Token Management

    /// Refresh access token if available
    public func refreshTokenIfNeeded() async {
        guard let provider = tokenStorage.getCurrentProvider() else { return }

        switch provider {
        case .google:
            await refreshGoogleToken()
        case .apple:
            // Apple tokens don't typically need refreshing in the same way
            break
        }
    }

    private func refreshGoogleToken() async {
        guard let googleCredentials = tokenStorage.getGoogleCredentials(),
              let refreshToken = googleCredentials.refreshToken else { return }

        guard let clientID = ProcessInfo.processInfo.environment["GOOGLE_OAUTH_CLIENT_ID"],
              let clientSecret = ProcessInfo.processInfo.environment["GOOGLE_OAUTH_CLIENT_SECRET"] else { return }

        do {
            let tokenResponse = try await GmailOAuthHelper.refreshAccessToken(
                refreshToken: refreshToken,
                clientID: clientID,
                clientSecret: clientSecret
            )

            tokenStorage.updateGoogleAccessToken(tokenResponse.accessToken, refreshToken: tokenResponse.refreshToken)

            // Update stored token info
            let tokenInfo = TokenInfo(
                accessToken: tokenResponse.accessToken,
                refreshToken: tokenResponse.refreshToken,
                expiresIn: tokenResponse.expiresIn,
                tokenType: tokenResponse.tokenType
            )
            tokenStorage.storeTokenInfo(tokenInfo, for: .google)

            logger.info("Google access token refreshed successfully")

        } catch {
            logger.error("Failed to refresh Google token: \(error.localizedDescription)")
            // Don't update auth state on refresh failure - user remains authenticated
        }
    }

    // MARK: - Private Methods

    private func updateAuthState(_ newState: AuthState) {
        authState = newState
    }

    private func checkAppleAuthStatus() {
        if let appleCredentials = tokenStorage.getAppleCredentials(),
           appleCredentials.userID != nil {

            let user = AuthUser(
                id: appleCredentials.userID!,
                email: appleCredentials.email ?? "",
                name: appleCredentials.name ?? "Apple User",
                provider: .apple
            )

            updateAuthState(.authenticated(user))
            logger.info("Restored Apple authentication for user: \(appleCredentials.email ?? "unknown")")
        }
    }

    private func checkLegacyAuthStatus() {
        // Check for legacy Keychain storage for backward compatibility
        if KeychainHelper.get(account: "apple_user_id") != nil {
            checkAppleAuthStatus()
        } else if KeychainHelper.get(account: "google_user_id") != nil {
            checkGoogleAuthStatus()
        }
    }
}
