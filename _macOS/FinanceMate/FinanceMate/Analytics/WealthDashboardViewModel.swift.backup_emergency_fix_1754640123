//
// WealthDashboardViewModel.swift
// FinanceMate
//
// P4-001 Wealth Dashboards Implementation - Enhanced Portfolio Analytics
// Created: 2025-07-11
// Target: FinanceMate
//

/*
 * Purpose: Comprehensive wealth dashboard with investment portfolio integration and advanced analytics
 * Issues & Complexity Summary: Complex integration of transaction and investment data with Charts framework
 * Key Complexity Drivers:
   - Logic Scope (Est. LoC): ~750
   - Core Algorithm Complexity: High (financial calculations, portfolio analytics, chart integration)
   - Dependencies: PortfolioManager, DashboardAnalyticsViewModel, Charts framework, Core Data
   - State Management Complexity: Very High (real-time portfolio updates, wealth calculations)
   - Novelty/Uncertainty Factor: Medium (investment analytics integration, performance calculations)
 * AI Pre-Task Self-Assessment: 85%
 * Problem Estimate: 88%
 * Initial Code Complexity Estimate: 90%
 * Final Code Complexity: [TBD]
 * Overall Result Score: [TBD]
 * Key Variances/Learnings: [TBD]
 * Last Updated: 2025-07-11
 */

import Foundation
import CoreData
import Charts
import SwiftUI
import OSLog
import Combine

// EMERGENCY FIX: Removed @MainActor to eliminate Swift Concurrency crashes
final class WealthDashboardViewModel: ObservableObject {
    
    // MARK: - Properties
    
    private let context: NSManagedObjectContext
    private let portfolioManager: PortfolioManager
    private let analyticsEngine: AnalyticsEngine
    private let logger = Logger(subsystem: "com.financemate.wealth", category: "WealthDashboard")
    
    // MARK: - Published State
    
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    
    // Overall Wealth Metrics
    @Published var totalNetWorth: Double = 0.0
    @Published var totalLiquidAssets: Double = 0.0
    @Published var totalInvestments: Double = 0.0
    @Published var totalLiabilities: Double = 0.0
    
    // Portfolio Performance Data
    @Published var portfolioPerformanceData: [PortfolioPerformancePoint] = []
    @Published var assetAllocationData: [AssetAllocationPoint] = []
    @Published var portfolioSummaries: [PortfolioSummary] = []
    
    // Investment Analytics
    @Published var topPerformingInvestments: [InvestmentPerformance] = []
    @Published var totalUnrealizedGains: Double = 0.0
    @Published var totalRealizedGains: Double = 0.0
    @Published var overallPortfolioReturn: Double = 0.0
    
    // Chart Interaction State
    @Published var selectedPortfolio: UUID?
    @Published var selectedTimeRange: TimeRange = .sixMonths
    @Published var showingDetailView: Bool = false
    
    // Real-time Update Management
    private var portfolioUpdateSubscription: AnyCancellable?
    private var dataRefreshTimer: Timer?
    
    // MARK: - Data Structures
    
    struct PortfolioPerformancePoint: Identifiable {
        let id = UUID()
        let date: Date
        let portfolioValue: Double
        let totalReturn: Double
        let returnPercentage: Double
    }
    
    struct AssetAllocationPoint: Identifiable {
        let id = UUID()
        let assetType: String
        let value: Double
        let percentage: Double
        let color: Color
    }
    
    struct PortfolioSummary: Identifiable {
        let id: UUID
        let name: String
        let totalValue: Double
        let totalReturn: Double
        let returnPercentage: Double
        let riskProfile: String
        let lastUpdated: Date
    }
    
    struct InvestmentPerformance: Identifiable {
        let id = UUID()
        let symbol: String
        let name: String
        let currentValue: Double
        let totalReturn: Double
        let returnPercentage: Double
        let assetType: String
    }
    
    enum TimeRange: String, CaseIterable {
        case oneMonth = "1M"
        case threeMonths = "3M"
        case sixMonths = "6M"
        case oneYear = "1Y"
        case twoYears = "2Y"
        case fiveYears = "5Y"
        
        var title: String {
            switch self {
            case .oneMonth: return "1 Month"
            case .threeMonths: return "3 Months"
            case .sixMonths: return "6 Months"
            case .oneYear: return "1 Year"
            case .twoYears: return "2 Years"
            case .fiveYears: return "5 Years"
            }
        }
        
        var dateInterval: TimeInterval {
            switch self {
            case .oneMonth: return -30 * 24 * 60 * 60
            case .threeMonths: return -90 * 24 * 60 * 60
            case .sixMonths: return -180 * 24 * 60 * 60
            case .oneYear: return -365 * 24 * 60 * 60
            case .twoYears: return -730 * 24 * 60 * 60
            case .fiveYears: return -1825 * 24 * 60 * 60
            }
        }
    }
    
    // MARK: - Initialization
    
    init(context: NSManagedObjectContext, portfolioManager: PortfolioManager, analyticsEngine: AnalyticsEngine) {
        self.context = context
        self.portfolioManager = portfolioManager
        self.analyticsEngine = analyticsEngine
        
        logger.info("WealthDashboardViewModel initialized")
        setupPortfolioMonitoring()
    }
    
    deinit {
        portfolioUpdateSubscription?.cancel()
        dataRefreshTimer?.invalidate()
    }
    
    // MARK: - Public Methods
    
    /// Load comprehensive wealth dashboard data
    func loadWealthData() {
        isLoading = true
        errorMessage = nil
        
        do {
            async let portfolioData = loadPortfolioData()
            async let assetAllocation = loadAssetAllocation()
            async let performanceMetrics = loadPerformanceMetrics()
            async let investmentAnalytics = loadInvestmentAnalytics()
            
            // Wait for all data to load
            let (_, _, _, _) = try (portfolioData, assetAllocation, performanceMetrics, investmentAnalytics)
            
            // Calculate overall wealth metrics
            calculateWealthMetrics()
            
            logger.info("Wealth dashboard data loaded successfully")
        } catch {
            logger.error("Failed to load wealth data: \(error.localizedDescription)")
            errorMessage = "Failed to load wealth dashboard: \(error.localizedDescription)"
        }
        
        isLoading = false
    }
    
    /// Refresh all dashboard data
    func refreshWealthData() {
        loadWealthData()
    }
    
    /// Update time range for charts
    func updateTimeRange() {
        selectedTimeRange = range
        loadPortfolioPerformanceData()
    }
    
    /// Select portfolio for detailed view
    func selectPortfolio(_ portfolioId: UUID) {
        selectedPortfolio = portfolioId
        showingDetailView = true
    }
    
    // MARK: - Private Methods
    
    private func setupPortfolioMonitoring() {
        // Monitor Core Data changes for real-time updates
        portfolioUpdateSubscription = NotificationCenter.default
            .publisher(for: .NSManagedObjectContextDidSave)
            .debounce(for: .seconds(1), scheduler: DispatchQueue.main)
            .sink { [weak self] _ in
                // EMERGENCY FIX: Removed Task block - immediate execution
        self?.loadWealthData()
            }
    }
    
    private func loadPortfolioData() throws {
        // Get all portfolios for the current user/entity
        // For now, we'll use a mock entity ID - in production this would come from authentication
        let mockEntityId = UUID() // This should be replaced with actual user entity ID
        
        let portfolios = try portfolioManager.getPortfolios(for: mockEntityId)
        
        var summaries: [PortfolioSummary] = []
        
        for portfolio in portfolios {
            guard let portfolioId = portfolio.id else { continue }
            
            let performanceMetrics = try portfolioManager.calculatePerformanceMetrics(portfolioId)
            
            let summary = PortfolioSummary(
                id: portfolioId,
                name: portfolio.name ?? "Portfolio",
                totalValue: portfolio.totalValue,
                totalReturn: performanceMetrics.totalReturn,
                returnPercentage: performanceMetrics.totalReturnPercentage,
                riskProfile: portfolio.riskProfile ?? "Unknown",
                lastUpdated: portfolio.lastUpdated ?? Date()
            )
            
            summaries.append(summary)
        }
        
        portfolioSummaries = summaries
    }
    
    private func loadAssetAllocation() throws {
        var allocationData: [AssetAllocationPoint] = []
        var totalValue: Double = 0.0
        
        // Aggregate asset allocation across all portfolios
        var assetTypeValues: [String: Double] = [:]
        
        for portfolio in portfolioSummaries {
            // For each portfolio, get holdings and aggregate by asset type
            // This would integrate with actual portfolio holdings data
            
            // Mock data for demonstration - replace with actual portfolio holdings
            let mockAllocations = [
                ("Stocks", portfolio.totalValue * 0.6),
                ("ETFs", portfolio.totalValue * 0.3),
                ("Bonds", portfolio.totalValue * 0.1)
            ]
            
            for (assetType, value) in mockAllocations {
                assetTypeValues[assetType, default: 0.0] += value
                totalValue += value
            }
        }
        
        // Convert to chart data with colors
        let colors: [Color] = [.blue, .green, .orange, .purple, .red, .yellow]
        
        for (index, (assetType, value)) in assetTypeValues.enumerated() {
            let percentage = totalValue > 0 ? (value / totalValue) : 0.0
            let color = colors[index % colors.count]
            
            allocationData.append(
                AssetAllocationPoint(
                    assetType: assetType,
                    value: value,
                    percentage: percentage,
                    color: color
                )
            )
        }
        
        assetAllocationData = allocationData
    }
    
    private func loadPerformanceMetrics() throws {
        var totalReturn: Double = 0.0
        var totalUnrealized: Double = 0.0
        var totalRealized: Double = 0.0
        
        for portfolio in portfolioSummaries {
            totalReturn += portfolio.totalReturn
            
            // Calculate unrealized vs realized gains
            // This would integrate with actual transaction data
            totalUnrealized += portfolio.totalReturn * 0.8 // Mock: 80% unrealized
            totalRealized += portfolio.totalReturn * 0.2 // Mock: 20% realized
        }
        
        overallPortfolioReturn = totalReturn
        totalUnrealizedGains = totalUnrealized
        totalRealizedGains = totalRealized
    }
    
    private func loadInvestmentAnalytics() throws {
        var topPerformers: [InvestmentPerformance] = []
        
        // Mock top performing investments - replace with actual data
        let mockInvestments = [
            ("AAPL", "Apple Inc.", 50000.0, 12500.0, 33.3, "Stock"),
            ("VAS", "Vanguard Australian Shares", 25000.0, 2750.0, 12.4, "ETF"),
            ("CBA", "Commonwealth Bank", 30000.0, 3600.0, 13.6, "Stock"),
            ("BTC", "Bitcoin", 15000.0, 5000.0, 50.0, "Cryptocurrency"),
            ("VDHG", "Vanguard Diversified High Growth", 20000.0, 1800.0, 9.9, "ETF")
        ]
        
        for (symbol, name, value, returnValue, returnPercentage, assetType) in mockInvestments {
            topPerformers.append(
                InvestmentPerformance(
                    symbol: symbol,
                    name: name,
                    currentValue: value,
                    totalReturn: returnValue,
                    returnPercentage: returnPercentage,
                    assetType: assetType
                )
            )
        }
        
        // Sort by return percentage descending
        topPerformingInvestments = topPerformers.sorted { $0.returnPercentage > $1.returnPercentage }
    }
    
    private func loadPortfolioPerformanceData() {
        var performanceData: [PortfolioPerformancePoint] = []
        
        // Generate mock historical performance data based on selected time range
        let endDate = Date()
        let startDate = Date(timeIntervalSinceNow: selectedTimeRange.dateInterval)
        
        let calendar = Calendar.current
        var currentDate = startDate
        
        while currentDate <= endDate {
            // Mock performance calculation - replace with actual historical data
            let daysSinceStart = calendar.dateComponents([.day], from: startDate, to: currentDate).day ?? 0
            let baseValue = 100000.0 // Starting portfolio value
            let randomVariation = Double.random(in: -0.02...0.02) // ±2% daily variation
            let overallGrowth = 0.08 * (Double(daysSinceStart) / 365.0) // 8% annual growth
            
            let portfolioValue = baseValue * (1.0 + overallGrowth + randomVariation)
            let totalReturn = portfolioValue - baseValue
            let returnPercentage = (totalReturn / baseValue) * 100.0
            
            performanceData.append(
                PortfolioPerformancePoint(
                    date: currentDate,
                    portfolioValue: portfolioValue,
                    totalReturn: totalReturn,
                    returnPercentage: returnPercentage
                )
            )
            
            currentDate = calendar.date(byAdding: .day, value: 1, to: currentDate) ?? currentDate
        }
        
        portfolioPerformanceData = performanceData
    }
    
    private func calculateWealthMetrics() {
        // Calculate overall wealth metrics
        totalInvestments = portfolioSummaries.reduce(0) { $0 + $1.totalValue }
        
        // Mock additional wealth components - replace with actual data
        totalLiquidAssets = 50000.0 // Cash, savings accounts
        totalLiabilities = 200000.0 // Mortgages, loans
        
        totalNetWorth = totalLiquidAssets + totalInvestments - totalLiabilities
        
        logger.info("Calculated wealth metrics - Net Worth: \(totalNetWorth), Investments: \(totalInvestments)")
    }
    
    // MARK: - Utility Methods
    
    func formattedCurrency(_ amount: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "en_AU")
        formatter.currencyCode = "AUD"
        return formatter.string(from: NSNumber(value: amount)) ?? "A$0.00"
    }
    
    func formattedPercentage(_ percentage: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .percent
        formatter.minimumFractionDigits = 1
        formatter.maximumFractionDigits = 2
        return formatter.string(from: NSNumber(value: percentage / 100.0)) ?? "0.0%"
    }
}

// MARK: - Mock Analytics Engine

// For now, we'll create a mock analytics engine
// In production, this would be replaced with the actual AnalyticsEngine
class AnalyticsEngine {
    // Mock implementation
}