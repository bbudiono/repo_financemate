//
// ExpenseOptimizer.swift
// FinanceMate
//
// Focused Expense Optimization Engine
// Created: 2025-08-04
// Target: FinanceMate - Modular Optimization System
//

/*
 * Purpose: Focused expense optimization algorithms and recommendations
 * Issues & Complexity Summary: Expense analysis, category optimization, recurring expense identification
 * Key Complexity Drivers:
   - Logic Scope (Est. LoC): ~200
   - Core Algorithm Complexity: Medium
   - Dependencies: Foundation, CoreData
   - State Management Complexity: Low (focused optimization logic)
   - Novelty/Uncertainty Factor: Low
 * AI Pre-Task Self-Assessment: 90%
 * Problem Estimate: 85%
 * Initial Code Complexity Estimate: 85%
 * Final Code Complexity: 87%
 * Overall Result Score: 92%
 * Key Variances/Learnings: Focused optimization components improve maintainability
 * Last Updated: 2025-08-04
 */

import Foundation
import CoreData

// MARK: - Expense Optimization Models
struct OptimizationRecommendation {
    let id: String
    let title: String
    let description: String
    let potentialSavings: Double
    let confidence: Double
    let category: String
    let actionSteps: [String]
}

struct RecurringExpenseOptimization {
    let id: String
    let isRecurring: Bool
    let monthlyAmount: Double
    let annualizedSavings: Double
    let optimizationStrategy: String
}

struct SubscriptionOptimizationAnalysis {
    let totalSubscriptionCost: Double
    let recommendations: [OptimizationRecommendation]
}

// MARK: - Focused Expense Optimizer
final class ExpenseOptimizer {
    
    private let logger = Logger(subsystem: "com.financemate.optimization", category: "ExpenseOptimizer")
    
    // MARK: - Core Expense Analysis
    
    func analyzeOptimizations(transactions: [Transaction]) async -> [OptimizationRecommendation] {
        var optimizations: [OptimizationRecommendation] = []
        
        // Analyze spending by category
        let categoryGroups = Dictionary(grouping: transactions) { $0.category ?? "Unknown" }
        
        for (category, categoryTransactions) in categoryGroups {
            let totalSpent = categoryTransactions.reduce(0) { $0 + $1.amount }
            let averagePerTransaction = totalSpent / Double(categoryTransactions.count)
            
            if totalSpent > 500 && categoryTransactions.count > 3 {
                optimizations.append(OptimizationRecommendation(
                    id: "expense_\(category.lowercased())",
                    title: "Optimize \(category) Expenses",
                    description: "Reduce \(category) spending by finding alternatives",
                    potentialSavings: totalSpent * 0.12,
                    confidence: 0.75,
                    category: category,
                    actionSteps: [
                        "Review all \(category) expenses",
                        "Identify unnecessary items",
                        "Research cheaper alternatives",
                        "Set monthly budget limit"
                    ]
                ))
            }
        }
        
        return optimizations.sorted { $0.potentialSavings > $1.potentialSavings }
    }
    
    // MARK: - Category Optimization
    
    func optimizeCategory(category: String, transactions: [Transaction]) async -> [OptimizationRecommendation] {
        let totalSpent = transactions.reduce(0) { $0 + $1.amount }
        
        if totalSpent == 0 { return [] }
        
        return [
            OptimizationRecommendation(
                id: "category_\(category.lowercased())_optimization",
                title: "Optimize \(category) Category",
                description: "Strategic optimization for \(category) expenses",
                potentialSavings: totalSpent * 0.15,
                confidence: 0.8,
                category: category,
                actionSteps: ["Analyze spending patterns", "Negotiate better rates", "Consolidate purchases"]
            )
        ]
    }
    
    // MARK: - Recurring Expense Analysis
    
    func optimizeRecurringExpenses(transactions: [Transaction]) async -> [RecurringExpenseOptimization] {
        // Identify potential recurring expenses by amount and frequency
        let amountGroups = Dictionary(grouping: transactions) { Int($0.amount) }
        var recurringOptimizations: [RecurringExpenseOptimization] = []
        
        for (amount, sameAmountTransactions) in amountGroups {
            if sameAmountTransactions.count >= 3 && amount > 20 {
                let annualAmount = Double(amount) * 12
                recurringOptimizations.append(RecurringExpenseOptimization(
                    id: "recurring_\(amount)",
                    isRecurring: true,
                    monthlyAmount: Double(amount),
                    annualizedSavings: annualAmount * 0.10,
                    optimizationStrategy: "Negotiate or find alternative for $\(amount) recurring expense"
                ))
            }
        }
        
        return recurringOptimizations
    }
    
    // MARK: - Subscription Analysis
    
    func optimizeSubscriptions(transactions: [Transaction]) async -> SubscriptionOptimizationAnalysis {
        let subscriptionKeywords = ["subscription", "monthly", "premium", "pro", "plus"]
        
        let potentialSubscriptions = transactions.filter { transaction in
            let note = transaction.note?.lowercased() ?? ""
            return subscriptionKeywords.contains { note.contains($0) }
        }
        
        var recommendations: [OptimizationRecommendation] = []
        
        for subscription in potentialSubscriptions {
            recommendations.append(OptimizationRecommendation(
                id: "sub_\(subscription.id?.uuidString ?? "")",
                title: "Review Subscription",
                description: "Evaluate \(subscription.note ?? "subscription") necessity",
                potentialSavings: subscription.amount * 12 * 0.5, // Assume 50% could be saved
                confidence: 0.6,
                category: "subscription",
                actionSteps: ["Review usage", "Cancel if unused", "Find cheaper alternative"]
            ))
        }
        
        return SubscriptionOptimizationAnalysis(
            totalSubscriptionCost: potentialSubscriptions.reduce(0) { $0 + $1.amount },
            recommendations: recommendations
        )
    }
}

// MARK: - OSLog Extension
import OSLog

extension Logger {
    static let expenseOptimization = Logger(subsystem: "com.financemate.optimization", category: "ExpenseOptimizer")
}