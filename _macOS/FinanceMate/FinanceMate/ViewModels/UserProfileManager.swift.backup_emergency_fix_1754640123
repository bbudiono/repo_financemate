//
// UserProfileManager.swift
// FinanceMate
//
// Purpose: User state and profile data management for FinanceMate
// Issues & Complexity Summary: User profile data, account management, validation
// Key Complexity Drivers:
//   - Logic Scope (Est. LoC): ~160
//   - Core Algorithm Complexity: Medium (User data validation, Account operations)
//   - Dependencies: 3 (Foundation, CoreData, Combine)
//   - State Management Complexity: Medium (User profile state)
//   - Novelty/Uncertainty Factor: Low (Standard user management patterns)
// AI Pre-Task Self-Assessment: 90%
// Problem Estimate: 85%
// Initial Code Complexity Estimate: 78%
// Final Code Complexity: TBD
// Overall Result Score: TBD
// Key Variances/Learnings: Clean user profile management with validation
// Last Updated: 2025-08-06

import Foundation
import CoreData
import Combine

// Import required types and services
// User is in User+CoreDataClass

// MARK: - User Profile Manager

// EMERGENCY FIX: Removed @MainActor to eliminate Swift Concurrency crashes
class UserProfileManager: ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var currentUser: User?
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    
    // MARK: - Private Properties
    
    private let context: NSManagedObjectContext
    
    // MARK: - Initialization
    
    init(context: NSManagedObjectContext) {
        self.context = context
    }
    
    // MARK: - User Management
    
    func createAccount() -> (success: Bool, user: User?, error: String?) {
        setLoading(true)
        clearError()
        
        do {
            // Validate input
            guard !name.isEmpty else {
                setError("Name is required")
                setLoading(false)
                return (success: false, user: nil, error: "Name is required")
            }
            
            guard validateEmail(email) else {
                setError("Invalid email format")
                setLoading(false)
                return (success: false, user: nil, error: "Invalid email format")
            }
            
            guard validatePassword(password) else {
                setError("Password must be at least 8 characters")
                setLoading(false)
                return (success: false, user: nil, error: "Password must be at least 8 characters")
            }
            
            // Check if user already exists
            if User.fetchUser(by: email, in: context) != nil {
                setError("User already exists")
                setLoading(false)
                return (success: false, user: nil, error: "User already exists")
            }
            
            // Create new user
            let user = User.create(
                in: context,
                name: name,
                email: email,
                role: .owner // First user is owner
            )
            
            try context.save()
            currentUser = user
            
            setLoading(false)
            return (success: true, user: user, error: nil)
            
        } catch {
            let errorMsg = "Failed to create account: \(error.localizedDescription)"
            setError(errorMsg)
            setLoading(false)
            return (success: false, user: nil, error: errorMsg)
        }
    }
    
    func resetPassword() -> (success: Bool, error: String?) {
        setLoading(true)
        clearError()
        
        do {
            // Validate email
            guard validateEmail(email) else {
                setError("Invalid email format")
                setLoading(false)
                return (success: false, error: "Invalid email format")
            }
            
            // Check if user exists
            guard User.fetchUser(by: email, in: context) != nil else {
                setError("User not found")
                setLoading(false)
                return (success: false, error: "User not found")
            }
            
            // In a real implementation, this would send a password reset email
            // For now, we'll just show a success message
            setLoading(false)
            return (success: true, error: nil)
            
        } catch {
            let errorMsg = "Failed to reset password: \(error.localizedDescription)"
            setError(errorMsg)
            setLoading(false)
            return (success: false, error: errorMsg)
        }
    }
    
    func updateUserProfile() -> (success: Bool, error: String?) {
        guard let user = currentUser else {
            return (success: false, error: "No current user to update")
        }
        
        setLoading(true)
        clearError()
        
        do {
            // Update provided fields
            if let name = name, !name.isEmpty {
                user.name = name
            }
            
            if let email = email {
                guard validateEmail(email) else {
                    setError("Invalid email format")
                    setLoading(false)
                    return (success: false, error: "Invalid email format")
                }
                user.email = email
            }
            
            if let currency = preferredCurrency {
                user.preferredCurrency = currency
            }
            
            if let tz = timezone {
                user.timezone = tz
            }
            
            // Save changes
            try context.save()
            
            setLoading(false)
            return (success: true, error: nil)
            
        } catch {
            let errorMsg = "Failed to update profile: \(error.localizedDescription)"
            setError(errorMsg)
            setLoading(false)
            return (success: false, error: errorMsg)
        }
    }
    
    func deleteUserAccount() -> (success: Bool, error: String?) {
        setLoading(true)
        clearError()
        
        do {
            guard let user = currentUser else {
                setError("No active user to delete")
                setLoading(false)
                return (success: false, error: "No active user to delete")
            }
            
            // In a real implementation, this would:
            // 1. Delete all user data
            // 2. Anonymize any audit logs
            // 3. Revoke all sessions
            // 4. Clear keychain data
            
            context.delete(user)
            try context.save()
            
            currentUser = nil
            
            setLoading(false)
            return (success: true, error: nil)
            
        } catch {
            let errorMsg = "Failed to delete account: \(error.localizedDescription)"
            setError(errorMsg)
            setLoading(false)
            return (success: false, error: errorMsg)
        }
    }
    
    // MARK: - User State Management
    
    func setCurrentUser(_ user: User?) {
        currentUser = user
    }
    
    func updateLastLogin() {
        currentUser?.updateLastLogin()
        
        do {
            try context.save()
        } catch {
            print("Failed to update last login: \(error)")
        }
    }
    
    func activateUser() {
        currentUser?.activate()
        
        do {
            try context.save()
        } catch {
            print("Failed to activate user: \(error)")
        }
    }
    
    func deactivateUser() {
        currentUser?.isActive = false
        
        do {
            try context.save()
        } catch {
            print("Failed to deactivate user: \(error)")
        }
    }
    
    // MARK: - Privacy and Security
    
    func getPrivacyCompliantUserData() -> [String: Any] {
        guard let user = currentUser else { return [:] }
        
        return [
            "name": user.name,
            "email": user.email,
            "role": user.role,
            "createdAt": user.createdAt,
            "isActive": user.isActive
        ]
    }
    
    func exportUserData() -> (data: [String: Any]?, error: String?) {
        guard let user = currentUser else {
            return (data: nil, error: "No current user")
        }
        
        setLoading(true)
        
        let userData = [
            "profile": getPrivacyCompliantUserData(),
            "preferences": [
                "preferredCurrency": user.preferredCurrency ?? "AUD",
                "timezone": user.timezone ?? "Australia/Sydney"
            ],
            "statistics": [
                "entityCount": user.entityCount,
                "daysSinceLastLogin": user.daysSinceLastLogin ?? 0
            ]
        ]
        
        setLoading(false)
        return (data: userData, error: nil)
    }
    
    // MARK: - Validation
    
    func validateEmail(_ email: String) -> Bool {
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: email)
    }
    
    func validatePassword(_ password: String) -> Bool {
        return password.count >= 8
    }
    
    func validateMFACode(_ code: String) -> Bool {
        return code.count == 6 && code.allSatisfy { $0.isNumber }
    }
    
    // MARK: - Helper Methods
    
    private func setLoading() {
        isLoading = loading
    }
    
    private func setError() {
        errorMessage = message
    }
    
    private func clearError() {
        errorMessage = nil
    }
}