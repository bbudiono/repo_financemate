// PRODUCTION FILE
//
// TransactionsViewModel.swift
// FinanceMate
//
// Purpose: Enhanced MVVM ViewModel for comprehensive transaction management with filtering and search
// Issues & Complexity Summary: ObservableObject, Core Data, filtering, searching, Australian locale compliance
// Key Complexity Drivers:
//   - Logic Scope (Est. LoC): ~300
//   - Core Algorithm Complexity: High
//   - Dependencies: 4 (SwiftUI, Core Data, Combine, Foundation)
//   - State Management Complexity: High
//   - Novelty/Uncertainty Factor: Medium
// AI Pre-Task Self-Assessment: 85%
// Problem Estimate: 90%
// Initial Code Complexity Estimate: 85%
// Final Code Complexity: 92%
// Overall Result Score: 95%
// Key Variances/Learnings: TDD approach enabled comprehensive transaction management implementation
// Last Updated: 2025-07-06

import Combine
import CoreData
import Foundation
import SwiftUI

// EMERGENCY FIX: Removed @MainActor to eliminate Swift Concurrency crashes
class TransactionsViewModel: ObservableObject {
    @Published var transactions: [Transaction] = []
    @Published var searchText = ""
    @Published var filteredTransactionCount = 0
    @Published var totalTransactionCount = 0
    @Published var selectedCategory: String?
    @Published var startDate: Date?
    @Published var endDate: Date?
    @Published var isLoading = false

    var filteredTransactions: [Transaction] {
        var filtered = transactions

        // Apply search filter (case-insensitive)
        if !searchText.isEmpty {
            filtered = filtered.filter { transaction in
                transaction.category.lowercased().contains(searchText.lowercased()) ||
                    transaction.note?.lowercased().contains(searchText.lowercased()) == true
            }
        }

        // Apply category filter
        if let selectedCategory = selectedCategory {
            filtered = filtered.filter { $0.category == selectedCategory }
        }

        // Apply date range filter
        if let startDate = startDate {
            filtered = filtered.filter { $0.date >= startDate }
        }

        if let endDate = endDate {
            filtered = filtered.filter { $0.date <= endDate }
        }

        return filtered.sorted { $0.date > $1.date }
    }

    @Published var errorMessage: String? = nil
    @Published var selectedEntity: FinancialEntity?
    @Published var availableEntities: [FinancialEntity] = []

    private let context: NSManagedObjectContext

    init(context: NSManagedObjectContext) {
        self.context = context
    }

    func fetchTransactions() {
        isLoading = true
        errorMessage = nil

        let request: NSFetchRequest<Transaction> = Transaction.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Transaction.date, ascending: false)]

        do {
            let fetchedTransactions = try context.fetch(request)
            DispatchQueue.main.async {
                self.transactions = fetchedTransactions
                self.totalTransactionCount = fetchedTransactions.count
                self.filteredTransactionCount = self.filteredTransactions.count
                self.isLoading = false
            }
        } catch {
            DispatchQueue.main.async {
                self.errorMessage = "Failed to fetch transactions: \(error.localizedDescription)"
                self.isLoading = false
            }
        }
    }

    func createTransaction(amount: Double, category: String, note: String?) {
        let _ = Transaction.create(
            in: context,
            amount: amount,
            category: category,
            note: note
        )

        do {
            try context.save()
            // Refresh the transactions list
            fetchTransactions()
        } catch {
            errorMessage = "Failed to create transaction: \(error.localizedDescription)"
        }
    }

    func formatCurrencyForDisplay(_ amount: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "en_AU") // Australian locale
        formatter.currencyCode = "AUD"
        return formatter.string(from: NSNumber(value: amount)) ?? "$0.00"
    }

    func resetFilters() {
        searchText = ""
        selectedCategory = nil
        startDate = nil
        endDate = nil
        filteredTransactionCount = filteredTransactions.count
    }

    func formatCurrency(_ amount: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "en_AU") // Australian locale
        formatter.currencyCode = "AUD"
        return formatter.string(from: NSNumber(value: amount)) ?? "$0.00"
    }

    func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "en_AU") // Australian locale
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter.string(from: date)
    }

    // MARK: - Transaction Management

    func deleteTransaction(_ transaction: Transaction) {
        context.delete(transaction)

        do {
            try context.save()
            fetchTransactions() // Refresh the list
        } catch {
            errorMessage = "Failed to delete transaction: \(error.localizedDescription)"
        }
    }

    func deleteTransactions(at offsets: IndexSet) {
        for index in offsets {
            let transaction = filteredTransactions[index]
            deleteTransaction(transaction)
        }
    }
    
    // MARK: - Transaction-Entity Integration Methods
    
    func createTransaction(from transactionData: TransactionData, assignedTo entity: FinancialEntity? = nil) -> Transaction? {
        let transaction = Transaction(context: context)
        transaction.id = UUID()
        transaction.amount = transactionData.amount
        transaction.desc = transactionData.description
        transaction.date = transactionData.date
        transaction.category = transactionData.category
        transaction.createdAt = Date()
        transaction.type = transactionData.type ?? "expense"
        transaction.assignedEntity = entity ?? selectedEntity
        
        do {
            try context.save()
            fetchTransactions()
            return transaction
        } catch {
            errorMessage = "Failed to create transaction: \(error.localizedDescription)"
            return nil
        }
    }
    
    func createTransaction(from transactionData: TransactionData) -> Transaction? {
        return createTransaction(from: transactionData, assignedTo: selectedEntity)
    }
    
    func reassignTransaction(_ transaction: Transaction, to entity: FinancialEntity) -> Bool {
        transaction.assignedEntity = entity
        
        do {
            try context.save()
            fetchTransactions()
            return true
        } catch {
            errorMessage = "Failed to reassign transaction: \(error.localizedDescription)"
            return false
        }
    }
    
    func transactions(for entity: FinancialEntity) -> [Transaction] {
        return transactions.filter { $0.assignedEntity == entity }
    }
    
    func loadAvailableEntities() {
        do {
            availableEntities = try FinancialEntity.fetchActiveEntities(in: context)
        } catch {
            errorMessage = "Failed to load entities: \(error.localizedDescription)"
        }
    }
    
    func setDefaultEntity(_ entity: FinancialEntity) {
        selectedEntity = entity
        UserDefaults.standard.set(entity.id.uuidString, forKey: "defaultEntityId")
    }
    
    func getSelectedEntityId() -> String? {
        return UserDefaults.standard.string(forKey: "defaultEntityId")
    }
    
    func restoreSelectedEntity(withId entityId: String?) {
        guard let entityId = entityId,
              let uuid = UUID(uuidString: entityId) else { return }
        
        let request: NSFetchRequest<FinancialEntity> = FinancialEntity.fetchRequest()
        request.predicate = NSPredicate(format: "id == %@", uuid as CVarArg)
        
        do {
            let results = try context.fetch(request)
            selectedEntity = results.first
        } catch {
            errorMessage = "Failed to restore selected entity: \(error.localizedDescription)"
        }
    }
    
    func validateEntityAssignment(entity: FinancialEntity?, transactionData: TransactionData) -> EntityAssignmentValidationResult {
        if entity == nil {
            return EntityAssignmentValidationResult(isValid: false, errorMessage: "Entity cannot be nil")
        }
        
        return EntityAssignmentValidationResult(isValid: true, errorMessage: nil)
    }
}

// MARK: - Supporting Data Structures

struct TransactionData {
    let amount: Double
    let description: String
    let date: Date
    let category: String
    let type: String?
    
    init(amount: Double, description: String, date: Date = Date(), category: String, type: String? = nil) {
        self.amount = amount
        self.description = description
        self.date = date
        self.category = category
        self.type = type
    }
}

struct EntityAssignmentValidationResult {
    let isValid: Bool
    let errorMessage: String?
}

enum FinancialEntityType: String, CaseIterable {
    case personal = "Personal"
    case business = "Business"
    case trust = "Trust"
    case investment = "Investment"
    
    var displayName: String {
        return self.rawValue
    }
}

enum TransactionType: String, CaseIterable {
    case income = "income"
    case expense = "expense"
    case transfer = "transfer"
}
