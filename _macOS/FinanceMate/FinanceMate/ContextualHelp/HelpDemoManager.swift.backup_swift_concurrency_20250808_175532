import Foundation
import OSLog

/// Interactive demo management for help system
/// Focused responsibility: Coordinate and manage interactive demonstrations
@MainActor
final class HelpDemoManager: ObservableObject {
    
    // MARK: - Properties
    
    private let logger = Logger(subsystem: "com.financemate.help", category: "HelpDemoManager")
    private var isAccessibilityModeEnabled: Bool = false
    
    // MARK: - Initialization
    
    init() {
        logger.debug("HelpDemoManager initialized")
    }
    
    // MARK: - Interactive Demo Generation
    
    /// Generate interactive demos for a specific context
    func generateInteractiveDemos(for context: HelpContext) -> [InteractiveDemo] {
        switch context {
        case .splitAllocation:
            return [HelpDemoFactory.createSplitAllocationDemo()]
            
        case .transactionEntry:
            return [HelpDemoFactory.createTransactionEntryDemo()]
            
        case .taxCategorySelection:
            return [HelpDemoFactory.createTaxCategoryDemo()]
            
        case .reporting:
            return [HelpDemoFactory.createReportingDemo()]
            
        case .analytics:
            return [HelpDemoFactory.createAnalyticsDemo()]
            
        case .dashboard:
            return [HelpDemoFactory.createDashboardDemo()]
            
        case .settings:
            return [HelpDemoFactory.createSettingsDemo()]
        }
    }
    
    /// Get all available interactive demos
    func getAllInteractiveDemos() -> [HelpContext: [InteractiveDemo]] {
        var allDemos: [HelpContext: [InteractiveDemo]] = [:]
        
        for context in HelpContext.allCases {
            let demos = generateInteractiveDemos(for: context)
            if !demos.isEmpty {
                allDemos[context] = demos
            }
        }
        
        return allDemos
    }
    
    /// Check if demos are available for a context
    func hasDemosAvailable(for context: HelpContext) -> Bool {
        return !generateInteractiveDemos(for: context).isEmpty
    }
    
    /// Get demo count for a context
    func getDemoCount(for context: HelpContext) -> Int {
        return generateInteractiveDemos(for: context).count
    }
    
    /// Get total steps across all demos for a context
    func getTotalSteps(for context: HelpContext) -> Int {
        let demos = generateInteractiveDemos(for: context)
        return demos.reduce(0) { $0 + $1.steps.count }
    }
    
    /// Get estimated duration for all demos in a context
    func getEstimatedDuration(for context: HelpContext) -> TimeInterval {
        let demos = generateInteractiveDemos(for: context)
        return demos.reduce(0) { $0 + $1.estimatedDuration }
    }
    
    /// Get demo by title for a specific context
    func getDemo(titled title: String, for context: HelpContext) -> InteractiveDemo? {
        return generateInteractiveDemos(for: context).first { $0.title == title }
    }
    
    /// Get demo statistics for all contexts
    func getDemoStatistics() -> [String: Any] {
        let allDemos = getAllInteractiveDemos()
        let totalDemos = allDemos.values.flatMap { $0 }.count
        let totalSteps = allDemos.values.flatMap { $0 }.reduce(0) { $0 + $1.steps.count }
        let totalDuration = allDemos.values.flatMap { $0 }.reduce(0) { $0 + $1.estimatedDuration }
        
        return [
            "totalContexts": HelpContext.allCases.count,
            "contextsWithDemos": allDemos.count,
            "totalDemos": totalDemos,
            "totalSteps": totalSteps,
            "totalEstimatedDuration": totalDuration,
            "averageDemoLength": totalDemos > 0 ? totalDuration / TimeInterval(totalDemos) : 0,
            "accessibilityEnabled": isAccessibilityModeEnabled
        ]
    }
    
    // MARK: - Accessibility Features
    
    /// Enable accessibility features for demos
    func enableAccessibilityMode(_ enabled: Bool) {
        self.isAccessibilityModeEnabled = enabled
        logger.info("Accessibility mode \(enabled ? "enabled" : "disabled") for interactive demos")
    }
    
    /// Get accessibility status for demos
    func isAccessibilityEnabled() -> Bool {
        return isAccessibilityModeEnabled
    }
    
    /// Validate demo accessibility for a context
    func validateDemoAccessibility(for context: HelpContext) -> [String: Bool] {
        let demos = generateInteractiveDemos(for: context)
        let hasAccessibleContent = !demos.isEmpty
        
        return [
            "hasDemos": hasAccessibleContent,
            "accessibilityMode": isAccessibilityModeEnabled,
            "canProvideAlternatives": hasAccessibleContent && isAccessibilityModeEnabled
        ]
    }
    
    // MARK: - Demo Content Analysis
    
    /// Get complexity level for demos in a context
    func getDemoComplexity(for context: HelpContext) -> DemoComplexity {
        let demos = generateInteractiveDemos(for: context)
        guard !demos.isEmpty else { return .none }
        
        let averageSteps = demos.reduce(0) { $0 + $1.steps.count } / demos.count
        
        switch averageSteps {
        case 1...2:
            return .simple
        case 3...4:
            return .moderate
        case 5...:
            return .complex
        default:
            return .none
        }
    }
    
    /// Get recommended demo order for a context
    func getRecommendedDemoOrder(for context: HelpContext) -> [InteractiveDemo] {
        let demos = generateInteractiveDemos(for: context)
        
        // Sort by estimated duration (shorter demos first)
        return demos.sorted { $0.estimatedDuration < $1.estimatedDuration }
    }
    
    /// Check if context has beginner-friendly demos
    func hasBeginnerFriendlyDemos(for context: HelpContext) -> Bool {
        let complexity = getDemoComplexity(for: context)
        return complexity == .simple || complexity == .moderate
    }
    
    /// Get demo content summary for a context
    func getDemoSummary(for context: HelpContext) -> DemoSummary {
        let demos = generateInteractiveDemos(for: context)
        
        return DemoSummary(
            context: context,
            demoCount: demos.count,
            totalSteps: demos.reduce(0) { $0 + $1.steps.count },
            estimatedDuration: demos.reduce(0) { $0 + $1.estimatedDuration },
            complexity: getDemoComplexity(for: context),
            isAccessible: isAccessibilityModeEnabled,
            isBeginnerFriendly: hasBeginnerFriendlyDemos(for: context)
        )
    }
}

// MARK: - Supporting Types

enum DemoComplexity {
    case none
    case simple
    case moderate
    case complex
}

struct DemoSummary {
    let context: HelpContext
    let demoCount: Int
    let totalSteps: Int
    let estimatedDuration: TimeInterval
    let complexity: DemoComplexity
    let isAccessible: Bool
    let isBeginnerFriendly: Bool
}