//
//  FinancialDataSyncManager.swift
//  FinanceMate
//
//  Created by Bernhard Budiono on 8/6/25.
//

import Foundation
import CoreData
import Combine

/// Orchestrates data synchronization between financial services and Core Data
/// Manages sync scheduling, conflict resolution, and data persistence
// EMERGENCY FIX: Removed @MainActor to eliminate Swift Concurrency crashes
final class FinancialDataSyncManager: ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var isSyncing: Bool = false
    @Published var lastSyncDate: Date?
    @Published var syncProgress: Double = 0.0
    @Published var syncStatus: SyncStatus = .idle
    @Published var syncErrors: [SyncError] = []
    
    // MARK: - Private Properties
    
    private let provider: FinancialDataProvider
    private let context: NSManagedObjectContext
    private var syncTimer: Timer?
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Types
    
    enum SyncStatus {
        case idle
        case syncing(String)
        case success
        case failed(Error)
    }
    
    struct SyncError: Identifiable {
        let id = UUID()
        let date: Date
        let message: String
        let isRecoverable: Bool
    }
    
    // MARK: - Initialization
    
    init(provider: FinancialDataProvider, context: NSManagedObjectContext) {
        self.provider = provider
        self.context = context
        
        loadLastSyncDate()
        setupAutoSync()
    }
    
    // MARK: - Public Methods
    
    /// Perform full synchronization of financial data
    func performFullSync() {
        guard !isSyncing else { return }
        
        isSyncing = true
        syncProgress = 0.0
        syncStatus = .syncing("Initializing sync...")
        syncErrors.removeAll()
        
        do {
            // Step 1: Fetch accounts (30% progress)
            syncStatus = .syncing("Fetching accounts...")
            let accounts = try provider.fetchAccounts()
            syncProgress = 0.3
            
            // Step 2: Save accounts to Core Data (40% progress)
            syncStatus = .syncing("Saving accounts...")
            try saveAccounts(accounts)
            syncProgress = 0.4
            
            // Step 3: Fetch transactions for each account (60% progress)
            syncStatus = .syncing("Fetching transactions...")
            var allTransactions: [BankTransaction] = []
            
            for (index, account) in accounts.enumerated() {
                let from = Calendar.current.date(
                    byAdding: .day,
                    value: -FinancialServicesConfig.transactionHistoryDays,
                    to: Date()
                )
                
                let transactions = try provider.fetchTransactions(
                    accountId: account.id,
                    from: from,
                    to: Date()
                )
                allTransactions.append(contentsOf: transactions)
                
                // Update progress
                let accountProgress = 0.2 * (Double(index + 1) / Double(accounts.count))
                syncProgress = 0.4 + accountProgress
            }
            
            // Step 4: Save transactions (80% progress)
            syncStatus = .syncing("Saving transactions...")
            try saveTransactions(allTransactions)
            syncProgress = 0.8
            
            // Step 5: Update sync metadata (100% progress)
            syncStatus = .syncing("Finalizing...")
            updateLastSyncDate()
            syncProgress = 1.0
            
            syncStatus = .success
            
        } catch {
            syncStatus = .failed(error)
            
            let syncError = SyncError(
                date: Date(),
                message: error.localizedDescription,
                isRecoverable: (error as? FinancialServiceError)?.isRetryable ?? false
            )
            syncErrors.append(syncError)
        }
        
        isSyncing = false
    }
    
    /// Perform incremental sync (only new data since last sync)
    func performIncrementalSync() {
        guard !isSyncing, let lastSync = lastSyncDate else {
            performFullSync()
            return
        }
        
        isSyncing = true
        syncProgress = 0.0
        syncStatus = .syncing("Checking for updates...")
        
        do {
            // Fetch only transactions since last sync
            let accounts = try provider.fetchAccounts()
            syncProgress = 0.3
            
            var newTransactions: [BankTransaction] = []
            for account in accounts {
                let transactions = try provider.fetchTransactions(
                    accountId: account.id,
                    from: lastSync,
                    to: Date()
                )
                newTransactions.append(contentsOf: transactions)
            }
            
            syncProgress = 0.6
            
            if !newTransactions.isEmpty {
                syncStatus = .syncing("Saving \(newTransactions.count) new transactions...")
                try saveTransactions(newTransactions)
            }
            
            updateLastSyncDate()
            syncProgress = 1.0
            syncStatus = .success
            
        } catch {
            syncStatus = .failed(error)
            let syncError = SyncError(
                date: Date(),
                message: error.localizedDescription,
                isRecoverable: true
            )
            syncErrors.append(syncError)
        }
        
        isSyncing = false
    }
    
    /// Start automatic synchronization
    func startAutoSync() {
        guard syncTimer == nil else { return }
        
        syncTimer = Timer.scheduledTimer(withTimeInterval: FinancialServicesConfig.syncInterval, repeats: true) { _ in
            // EMERGENCY FIX: Removed Task block - immediate execution
        self.performIncrementalSync()
        }
    }
    
    /// Stop automatic synchronization
    func stopAutoSync() {
        syncTimer?.invalidate()
        syncTimer = nil
    }
    
    // MARK: - Private Methods
    
    private func saveAccounts() throws {
        try context.perform {
            // Implementation would save accounts to Core Data
            // This is a placeholder for the actual Core Data operations
            // Will be implemented when Core Data models are extended
            
            try self.context.save()
        }
    }
    
    private func saveTransactions() throws {
        try context.perform {
            for bankTransaction in transactions {
                // Check if transaction already exists
                let fetchRequest = NSFetchRequest<Transaction>(entityName: "Transaction")
                fetchRequest.predicate = NSPredicate(format: "externalId == %@", bankTransaction.id)
                
                let existingTransactions = try self.context.fetch(fetchRequest)
                
                if existingTransactions.isEmpty {
                    // Create new transaction
                    let transaction = Transaction(context: self.context)
                    transaction.id = UUID()
                    transaction.amount = bankTransaction.signedAmount
                    transaction.date = bankTransaction.date
                    transaction.note = bankTransaction.description
                    transaction.category = bankTransaction.category ?? "Uncategorized"
                    transaction.externalId = bankTransaction.id
                    transaction.createdAt = Date()
                }
            }
            
            try self.context.save()
        }
    }
    
    private func setupAutoSync() {
        // Check if auto-sync is enabled in user preferences
        let autoSyncEnabled = UserDefaults.standard.bool(
            forKey: FinancialServicesConfig.UserDefaultsKeys.syncEnabled
        )
        
        if autoSyncEnabled {
            startAutoSync()
        }
    }
    
    private func loadLastSyncDate() {
        if let lastSync = UserDefaults.standard.object(
            forKey: FinancialServicesConfig.UserDefaultsKeys.lastSyncDate
        ) as? Date {
            lastSyncDate = lastSync
        }
    }
    
    private func updateLastSyncDate() {
        lastSyncDate = Date()
        UserDefaults.standard.set(
            lastSyncDate,
            forKey: FinancialServicesConfig.UserDefaultsKeys.lastSyncDate
        )
    }
    
    // MARK: - Cleanup
    
    deinit {
        stopAutoSync()
    }
}