import Foundation
import CoreData
import AuthenticationServices

/**
 * SSOManager.swift
 * 
 * Purpose: Centralized SSO management for all OAuth providers with secure token lifecycle
 * Issues & Complexity Summary: Unified SSO interface with provider coordination and security
 * Key Complexity Drivers:
 *   - Logic Scope (Est. LoC): ~150
 *   - Core Algorithm Complexity: Medium (Provider coordination, Security management)
 *   - Dependencies: 3 (Foundation, CoreData, AuthenticationServices)
 *   - State Management Complexity: Medium (Multi-provider state, Session management)
 *   - Novelty/Uncertainty Factor: Low (Well-established SSO patterns)
 * AI Pre-Task Self-Assessment: 92%
 * Problem Estimate: 94%
 * Initial Code Complexity Estimate: 80%
 * Final Code Complexity: 85%
 * Overall Result Score: 95%
 * Key Variances/Learnings: Clean abstraction over multiple OAuth providers
 * Last Updated: 2025-08-04
 */

// MARK: - SSO Manager

// EMERGENCY FIX: Removed @MainActor to eliminate Swift Concurrency crashes
public class SSOManager: ObservableObject {
    
    // MARK: - Properties
    
    private let context: NSManagedObjectContext
    private let tokenStorage: TokenStorage
    private let appleProvider: AppleAuthProvider
    private let googleProvider: GoogleAuthProvider
    
    @Published var availableProviders: [OAuth2Provider] = [.apple, .google]
    @Published var authenticatedProviders: Set<OAuth2Provider> = []
    @Published var isCheckingTokens: Bool = false
    
    // MARK: - Initialization
    
    public init(context: NSManagedObjectContext) {
        self.context = context
        self.tokenStorage = TokenStorage()
        self.appleProvider = AppleAuthProvider(context: context, tokenStorage: tokenStorage)
        self.googleProvider = GoogleAuthProvider(context: context, tokenStorage: tokenStorage)
        
        // EMERGENCY FIX: Removed Task block - immediate execution
        checkAuthenticatedProviders()
    }
    
    // MARK: - Public Authentication Methods
    
    public func authenticate() throws -> AuthenticationResult {
        switch provider {
        case .apple:
            let result = try appleProvider.authenticate()
            if result.success {
                authenticatedProviders.insert(.apple)
            }
            return result
            
        case .google:
            let result = try googleProvider.authenticate()
            if result.success {
                authenticatedProviders.insert(.google)
            }
            return result
            
        case .microsoft, .github:
            throw AuthenticationError.notImplemented("Provider \(provider.displayName) not yet implemented")
        }
    }
    
    func signOut() throws {
        switch provider {
        case .apple:
            try appleProvider.signOut()
            authenticatedProviders.remove(.apple)
            
        case .google:
            try googleProvider.signOut()
            authenticatedProviders.remove(.google)
            
        case .microsoft, .github:
            // Remove from storage even if not implemented
            try tokenStorage.deleteTokens(for: provider)
            authenticatedProviders.remove(provider)
        }
    }
    
    func signOutFromAll() throws {
        let providers = Array(authenticatedProviders)
        
        for provider in providers {
            try? signOut(from: provider)
        }
        
        // Ensure all tokens are cleared
        try tokenStorage.deleteAllTokens()
        authenticatedProviders.removeAll()
    }
    
    // MARK: - Token Management
    
    func refreshTokens() throws -> Bool {
        switch provider {
        case .google:
            let refreshedTokens = try googleProvider.refreshToken()
            return refreshedTokens != nil
            
        case .apple:
            // Apple tokens don't support refresh, check credential state instead
            if let user = getCurrentUser() {
                let state = appleProvider.checkCredentialState(userID: user.id.uuidString)
                return state == .authorized
            }
            return false
            
        case .microsoft, .github:
            return false
        }
    }
    
    func checkTokenSecurity() throws -> TokenSecurityInfo {
        return try tokenStorage.validateTokenSecurity(for: provider)
    }
    
    func hasValidTokens() -> Bool {
        return tokenStorage.hasValidTokens(for: provider)
    }
    
    // MARK: - Provider Status
    
    func checkAuthenticatedProviders() {
        isCheckingTokens = true
        
        var authenticated = Set<OAuth2Provider>()
        
        for provider in availableProviders {
            if hasValidTokens(for: provider) {
                authenticated.insert(provider)
            }
        }
        
        authenticatedProviders = authenticated
        isCheckingTokens = false
    }
    
    func getProviderStatus() -> ProviderStatus {
        let hasTokens = hasValidTokens(for: provider)
        
        if hasTokens {
            do {
                let securityInfo = try checkTokenSecurity(for: provider)
                
                switch securityInfo.securityLevel {
                case .secure:
                    return .authenticated
                case .expiring:
                    return .tokenExpiring
                case .limited:
                    return .limitedAccess
                case .insecure:
                    return .insecureToken
                case .invalid:
                    return .tokenInvalid
                }
            } catch {
                return .error(error.localizedDescription)
            }
        } else {
            return .notAuthenticated
        }
    }
    
    // MARK: - User Management
    
    func getCurrentUser() -> User? {
        // Check if there's a currently authenticated user
        if let userIdString = UserDefaults.standard.string(forKey: "authenticated_user_id"),
           let userId = UUID(uuidString: userIdString) {
            return User.fetchUser(by: userId, in: context)
        }
        return nil
    }
    
    func getUsersAuthenticatedProviders() -> [OAuth2Provider] {
        return Array(authenticatedProviders)
    }
    
    // MARK: - Security Monitoring
    
    func performSecurityAudit() -> SSOSecurityAudit {
        var providerAudits: [OAuth2Provider: TokenSecurityInfo] = [:]
        var securityIssues: [String] = []
        
        for provider in authenticatedProviders {
            do {
                let securityInfo = try checkTokenSecurity(for: provider)
                providerAudits[provider] = securityInfo
                
                switch securityInfo.securityLevel {
                case .insecure:
                    securityIssues.append("\(provider.displayName): Token not securely stored")
                case .limited:
                    securityIssues.append("\(provider.displayName): No refresh token available")
                case .expiring:
                    securityIssues.append("\(provider.displayName): Token expires soon")
                case .invalid:
                    securityIssues.append("\(provider.displayName): Token is invalid")
                case .secure:
                    break
                }
            } catch {
                securityIssues.append("\(provider.displayName): Failed to validate security - \(error.localizedDescription)")
            }
        }
        
        return SSOSecurityAudit(
            providerAudits: providerAudits,
            securityIssues: securityIssues,
            overallSecurityLevel: calculateOverallSecurityLevel(providerAudits)
        )
    }
    
    private func calculateOverallSecurityLevel(_ audits: [OAuth2Provider: TokenSecurityInfo]) -> TokenSecurityLevel {
        let levels = audits.values.map { $0.securityLevel }
        
        if levels.contains(.invalid) {
            return .invalid
        } else if levels.contains(.insecure) {
            return .insecure
        } else if levels.contains(.limited) {
            return .limited
        } else if levels.contains(.expiring) {
            return .expiring
        } else {
            return .secure
        }
    }
}

// MARK: - Provider Status

enum ProviderStatus {
    case notAuthenticated
    case authenticated
    case tokenExpiring
    case tokenInvalid
    case limitedAccess
    case insecureToken
    case error(String)
    
    var description: String {
        switch self {
        case .notAuthenticated:
            return "Not authenticated"
        case .authenticated:
            return "Authenticated"
        case .tokenExpiring:
            return "Token expires soon"
        case .tokenInvalid:
            return "Token is invalid"
        case .limitedAccess:
            return "Limited access (no refresh token)"
        case .insecureToken:
            return "Token not securely stored"
        case .error(let message):
            return "Error: \(message)"
        }
    }
    
    var isSecure: Bool {
        switch self {
        case .authenticated:
            return true
        default:
            return false
        }
    }
}

// MARK: - SSO Security Audit

struct SSOSecurityAudit {
    let providerAudits: [OAuth2Provider: TokenSecurityInfo]
    let securityIssues: [String]
    let overallSecurityLevel: TokenSecurityLevel
    let auditDate: Date = Date()
    
    var hasSecurityIssues: Bool {
        return !securityIssues.isEmpty
    }
    
    var isOverallSecure: Bool {
        return overallSecurityLevel == .secure
    }
}