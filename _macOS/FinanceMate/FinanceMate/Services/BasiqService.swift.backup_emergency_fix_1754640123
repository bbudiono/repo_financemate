//
//  BasiqService.swift
//  FinanceMate
//
//  Created by Bernhard Budiono on 8/6/25.
//

import Foundation
import Combine

/// Main service implementation for Basiq financial data aggregation
/// Implements FinancialDataProvider protocol for bank data integration
// EMERGENCY FIX: Removed @MainActor to eliminate Swift Concurrency crashes
final class BasiqService: FinancialDataProvider, ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var isConnected: Bool = false
    @Published var isLoading: Bool = false
    @Published var lastError: FinancialServiceError?
    @Published var currentConnection: ConnectionResult?
    
    // MARK: - Private Properties
    
    private let authManager: BasiqAuthenticationManager
    private let dataParser: BasiqDataParser
    private let session: URLSession
    private let baseURL: String
    private var currentUserId: String?
    
    // MARK: - SSO Integration
    
    /// Reference to authenticated user from SSO system
    weak var authenticationViewModel: AuthenticationViewModel?
    
    // MARK: - Initialization
    
    init(authenticationViewModel: AuthenticationViewModel? = nil) {
        let config = FinancialServicesConfig.self
        self.baseURL = config.basiqBaseURL
        self.authManager = BasiqAuthenticationManager(
            apiKey: config.basiqAPIKey,
            baseURL: baseURL
        )
        self.dataParser = BasiqDataParser()
        self.authenticationViewModel = authenticationViewModel
        
        // Configure session with proper timeout
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = config.requestTimeout
        self.session = URLSession(configuration: configuration)
    }
    
    // MARK: - FinancialDataProvider Implementation
    
    func connect() throws -> ConnectionResult {
        isLoading = true
        defer { isLoading = false }
        
        do {
            // Get access token
            let token = try authManager.getAccessToken()
            
            // Create user consent for institution
            let userId = try createUser(token: token)
            currentUserId = userId
            
            // Initiate connection to institution
            let connection = try createConnection(
                userId: userId,
                institutionId: institution,
                token: token
            )
            
            currentConnection = connection
            isConnected = true
            lastError = nil
            
            return connection
        } catch {
            lastError = error as? FinancialServiceError ?? .networkError(error)
            throw lastError!
        }
    }
    
    func fetchAccounts() throws -> [BankAccount] {
        guard let userId = currentUserId else {
            throw FinancialServiceError.authenticationRequired
        }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            let token = try authManager.getAccessToken()
            let url = URL(string: "\(baseURL)/users/\(userId)/accounts")!
            
            var request = URLRequest(url: url)
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            
            let (data, response) = try session.data(for: request)
            try validateResponse(response, data: data)
            
            let accounts = try dataParser.parseAccounts(from: data)
            lastError = nil
            return accounts
        } catch {
            lastError = error as? FinancialServiceError ?? .networkError(error)
            throw lastError!
        }
    }
    
    func fetchTransactions() throws -> [BankTransaction] {
        guard currentUserId != nil else {
            throw FinancialServiceError.authenticationRequired
        }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            let token = try authManager.getAccessToken()
            
            // Build URL with query parameters
            var components = URLComponents(string: "\(baseURL)/accounts/\(accountId)/transactions")!
            var queryItems: [URLQueryItem] = []
            
            if let from = from {
                let formatter = ISO8601DateFormatter()
                queryItems.append(URLQueryItem(name: "filter[from]", value: formatter.string(from: from)))
            }
            
            if let to = to {
                let formatter = ISO8601DateFormatter()
                queryItems.append(URLQueryItem(name: "filter[to]", value: formatter.string(from: to)))
            }
            
            queryItems.append(URLQueryItem(name: "limit", value: "500"))
            components.queryItems = queryItems
            
            var request = URLRequest(url: components.url!)
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            
            let (data, response) = try session.data(for: request)
            try validateResponse(response, data: data)
            
            let transactions = try dataParser.parseTransactions(from: data)
            lastError = nil
            return transactions
        } catch {
            lastError = error as? FinancialServiceError ?? .networkError(error)
            throw lastError!
        }
    }
    
    func refreshConnection() throws {
        guard let connection = currentConnection else {
            throw FinancialServiceError.authenticationRequired
        }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            // Refresh the OAuth token
            let token = try authManager.refreshToken()
            
            // Refresh account data
            _ = try fetchAccounts()
            
            // Update connection status
            currentConnection = ConnectionResult(
                sessionId: connection.sessionId,
                userId: connection.userId,
                institutionId: connection.institutionId,
                consentExpiresAt: connection.consentExpiresAt,
                lastRefreshed: Date()
            )
            
            lastError = nil
        } catch {
            lastError = error as? FinancialServiceError ?? .networkError(error)
            throw lastError!
        }
    }
    
    func disconnect() throws {
        isLoading = true
        defer { isLoading = false }
        
        // Clear authentication
        authManager.clearAuthentication()
        
        // Reset state
        currentUserId = nil
        currentConnection = nil
        isConnected = false
        lastError = nil
    }
    
    // MARK: - Private Methods
    
    private func createUser() throws -> String {
        let url = URL(string: "\(baseURL)/users")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Get authenticated user email from SSO system
        guard let authViewModel = authenticationViewModel,
              let currentUser = authViewModel.currentUser else {
            throw FinancialServiceError.authenticationRequired
        }
        
        // Create user with real authenticated user email from SSO
        let userData = ["email": currentUser.email]
        request.httpBody = try JSONSerialization.data(withJSONObject: userData)
        
        let (data, response) = try session.data(for: request)
        try validateResponse(response, data: data)
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let userId = json["id"] as? String else {
            throw FinancialServiceError.dataParsingError("Failed to parse user ID")
        }
        
        return userId
    }
    
    private func createConnection() throws -> ConnectionResult {
        let url = URL(string: "\(baseURL)/users/\(userId)/connections")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let connectionData = ["institution": ["id": institutionId]]
        request.httpBody = try JSONSerialization.data(withJSONObject: connectionData)
        
        let (data, response) = try session.data(for: request)
        try validateResponse(response, data: data)
        
        return try dataParser.parseConnection(from: data)
    }
    
    private func validateResponse(_ response: URLResponse, data: Data) throws {
        guard let httpResponse = response as? HTTPURLResponse else {
            throw FinancialServiceError.networkError(URLError(.badServerResponse))
        }
        
        switch httpResponse.statusCode {
        case 200...299:
            return // Success
        case 401:
            throw FinancialServiceError.authenticationRequired
        case 403:
            throw FinancialServiceError.insufficientPermissions
        case 404:
            throw FinancialServiceError.invalidRequest("Resource not found")
        case 429:
            let retryAfter = httpResponse.value(forHTTPHeaderField: "Retry-After")
                .flatMap { Double($0) } ?? 60
            throw FinancialServiceError.rateLimitExceeded(retryAfter: retryAfter)
        case 500...599:
            throw FinancialServiceError.serviceUnavailable
        default:
            let errorMessage = String(data: data, encoding: .utf8)
            throw FinancialServiceError.serverError(
                statusCode: httpResponse.statusCode,
                message: errorMessage
            )
        }
    }
}