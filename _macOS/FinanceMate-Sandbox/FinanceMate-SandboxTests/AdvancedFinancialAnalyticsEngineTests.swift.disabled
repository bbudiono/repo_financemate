// SANDBOX FILE: For testing/development. See .cursorrules.
//
// AdvancedFinancialAnalyticsEngineTests.swift
// FinanceMate-SandboxTests
//
// Purpose: Comprehensive TDD test suite for AdvancedFinancialAnalyticsEngine - drives real implementation
// Issues & Complexity Summary: Complex analytics engine testing with real financial data analysis
// Key Complexity Drivers:
//   - Logic Scope (Est. LoC): ~400
//   - Core Algorithm Complexity: High (complex financial calculations, trend analysis, anomaly detection)
//   - Dependencies: 6 New (XCTest, Core Data, financial calculations, date analysis, statistical methods, machine learning concepts)
//   - State Management Complexity: High (async analytics, progress tracking, real-time updates)
//   - Novelty/Uncertainty Factor: High (advanced analytics algorithms)
// AI Pre-Task Self-Assessment (Est. Solution Difficulty %): 85%
// Problem Estimate (Inherent Problem Difficulty %): 88%
// Initial Code Complexity Estimate %: 87%
// Justification for Estimates: Advanced financial analytics requires sophisticated algorithms and real-time calculation capabilities
// Final Code Complexity (Actual %): TBD
// Overall Result Score (Success & Quality %): TBD
// Key Variances/Learnings: TDD approach ensures robust analytics with real financial insights
// Last Updated: 2025-06-04

import XCTest
import CoreData
import Combine
@testable import FinanceMate_Sandbox

@MainActor
final class AdvancedFinancialAnalyticsEngineTests: XCTestCase {
    
    var analyticsEngine: AdvancedFinancialAnalyticsEngine!
    var testContext: NSManagedObjectContext!
    var persistentContainer: NSPersistentContainer!
    var cancellables: Set<AnyCancellable>!
    
    override func setUpWithError() throws {
        try super.setUpWithError()
        
        // Setup in-memory Core Data stack
        persistentContainer = NSPersistentContainer(name: "FinanceMateDataModel")
        let description = NSPersistentStoreDescription()
        description.type = NSInMemoryStoreType
        persistentContainer.persistentStoreDescriptions = [description]
        persistentContainer.loadPersistentStores { _, error in
            XCTAssertNil(error)
        }
        testContext = persistentContainer.viewContext
        
        // Initialize analytics engine
        analyticsEngine = AdvancedFinancialAnalyticsEngine()
        cancellables = Set<AnyCancellable>()
    }
    
    override func tearDownWithError() throws {
        cancellables?.removeAll()
        cancellables = nil
        analyticsEngine = nil
        testContext = nil
        persistentContainer = nil
        try super.tearDownWithError()
    }
    
    // MARK: - Initialization Tests
    
    func testAdvancedAnalyticsEngineInitialization() {
        // Given: Analytics engine is initialized
        // When: Engine is created
        // Then: Should be in proper initial state
        XCTAssertNotNil(analyticsEngine)
        XCTAssertFalse(analyticsEngine.isAnalyzing)
        XCTAssertEqual(analyticsEngine.currentProgress, 0.0)
        XCTAssertNil(analyticsEngine.lastAnalysisDate)
    }
    
    // MARK: - Advanced Report Generation Tests
    
    func testGenerateAdvancedReportWithRealData() async throws {
        // Given: Real financial data exists
        try createComprehensiveFinancialDataset()
        
        // When: Generating advanced report
        let report = try await analyticsEngine.generateAdvancedReport(from: fetchAllFinancialData())
        
        // Then: Should produce meaningful analytics
        XCTAssertNotNil(report)
        XCTAssertGreaterThan(report.totalTransactions, 0)
        XCTAssertGreaterThan(report.averageAmount, 0)
        XCTAssertFalse(report.categoryBreakdown.isEmpty)
        XCTAssertFalse(report.trendAnalysis.isEmpty)
        XCTAssertGreaterThanOrEqual(report.riskScore, 0.0)
        XCTAssertLessThanOrEqual(report.riskScore, 1.0)
        XCTAssertFalse(report.recommendations.isEmpty)
        XCTAssertNotNil(report.generatedDate)
    }
    
    func testGenerateAdvancedReportWithEmptyData() async throws {
        // Given: No financial data
        let emptyData: [FinancialData] = []
        
        // When: Generating advanced report
        let report = try await analyticsEngine.generateAdvancedReport(from: emptyData)
        
        // Then: Should handle empty data gracefully
        XCTAssertEqual(report.totalTransactions, 0)
        XCTAssertEqual(report.averageAmount, 0.0)
        XCTAssertTrue(report.categoryBreakdown.isEmpty)
        XCTAssertEqual(report.trendAnalysis, "No transaction data available for analysis")
        XCTAssertEqual(report.riskScore, 0.0)
        XCTAssertEqual(report.recommendations, ["Import financial documents to begin analysis"])
    }
    
    func testAdvancedReportProgressTracking() async throws {
        // Given: Financial data exists
        try createComprehensiveFinancialDataset()
        
        var progressUpdates: [Double] = []
        
        // When: Tracking progress during report generation
        analyticsEngine.$currentProgress
            .sink { progress in
                progressUpdates.append(progress)
            }
            .store(in: &cancellables)
        
        let _ = try await analyticsEngine.generateAdvancedReport(from: fetchAllFinancialData())
        
        // Then: Should track progress from 0 to 1
        XCTAssertTrue(progressUpdates.contains(0.0))
        XCTAssertTrue(progressUpdates.contains(1.0))
        XCTAssertGreaterThan(progressUpdates.count, 2) // Should have intermediate values
    }
    
    // MARK: - Spending Pattern Analysis Tests
    
    func testAnalyzeSpendingPatternsWithSeasonalData() async throws {
        // Given: Financial data across different seasons
        try createSeasonalFinancialData()
        
        // When: Analyzing spending patterns
        let analysis = try await analyticsEngine.analyzeSpendingPatterns(from: fetchAllFinancialData())
        
        // Then: Should detect seasonal patterns
        XCTAssertGreaterThan(analysis.monthlyAverage, 0)
        XCTAssertNotEqual(analysis.yearOverYearGrowth, 0) // Should calculate actual growth
        XCTAssertEqual(analysis.seasonalTrends.count, 4) // Q1, Q2, Q3, Q4
        XCTAssertFalse(analysis.categoryTrends.isEmpty)
        
        // Verify seasonal trends are meaningful
        let totalSeasonalWeight = analysis.seasonalTrends.values.reduce(0, +)
        XCTAssertEqual(totalSeasonalWeight, 4.0, accuracy: 0.1) // Should average to 1.0 per quarter
    }
    
    func testAnalyzeSpendingPatternsGrowthCalculation() async throws {
        // Given: Financial data with clear year-over-year trend
        try createYearOverYearGrowthData()
        
        // When: Analyzing spending patterns
        let analysis = try await analyticsEngine.analyzeSpendingPatterns(from: fetchAllFinancialData())
        
        // Then: Should calculate accurate growth percentage
        XCTAssertGreaterThan(analysis.yearOverYearGrowth, 0) // Positive growth expected
        XCTAssertLessThan(analysis.yearOverYearGrowth, 2.0) // Reasonable growth (less than 200%)
    }
    
    func testAnalyzeSpendingPatternsWithSingleCategory() async throws {
        // Given: Financial data with only one category
        try createSingleCategoryData()
        
        // When: Analyzing spending patterns
        let analysis = try await analyticsEngine.analyzeSpendingPatterns(from: fetchAllFinancialData())
        
        // Then: Should handle single category gracefully
        XCTAssertEqual(analysis.categoryTrends.count, 1)
        XCTAssertEqual(analysis.categoryTrends.values.first, 1.0, accuracy: 0.01) // Should be 100%
    }
    
    // MARK: - Anomaly Detection Tests
    
    func testDetectAnomaliesWithUnusualAmounts() async throws {
        // Given: Financial data with clear anomalies
        try createDataWithAnomalies()
        
        // When: Detecting anomalies
        let anomalies = try await analyticsEngine.detectAnomalies(from: fetchAllFinancialData())
        
        // Then: Should identify anomalies
        XCTAssertFalse(anomalies.isEmpty)
        
        // Verify anomaly structure
        for anomaly in anomalies {
            XCTAssertFalse(anomaly.description.isEmpty)
            XCTAssertGreaterThan(anomaly.confidence, 0.0)
            XCTAssertLessThanOrEqual(anomaly.confidence, 1.0)
            XCTAssertNotNil(anomaly.detectedDate)
        }
        
        // Should detect the unusual amount anomaly
        let hasUnusualAmount = anomalies.contains { $0.type == .unusualAmount }
        XCTAssertTrue(hasUnusualAmount)
    }
    
    func testDetectAnomaliesWithFrequencyChanges() async throws {
        // Given: Financial data with frequency anomalies
        try createDataWithFrequencyAnomalies()
        
        // When: Detecting anomalies
        let anomalies = try await analyticsEngine.detectAnomalies(from: fetchAllFinancialData())
        
        // Then: Should detect frequency changes
        let hasFrequencyChange = anomalies.contains { $0.type == .frequencyChange }
        XCTAssertTrue(hasFrequencyChange)
    }
    
    func testDetectAnomaliesWithNormalData() async throws {
        // Given: Normal financial data without anomalies
        try createNormalFinancialData()
        
        // When: Detecting anomalies
        let anomalies = try await analyticsEngine.detectAnomalies(from: fetchAllFinancialData())
        
        // Then: Should detect few or no anomalies
        XCTAssertLessThanOrEqual(anomalies.count, 1) // Allow for minor false positives
    }
    
    // MARK: - Real-time Trend Analysis Tests
    
    func testCalculateRealTimeTrends() async throws {
        // Given: Time-series financial data
        try createTimeSeriesData()
        
        // When: Calculating real-time trends
        let trends = try await analyticsEngine.calculateRealTimeTrends(from: fetchAllFinancialData())
        
        // Then: Should produce trend analysis
        XCTAssertNotNil(trends)
        XCTAssertFalse(trends.trendDirection.isEmpty)
        XCTAssertGreaterThanOrEqual(trends.trendStrength, 0.0)
        XCTAssertLessThanOrEqual(trends.trendStrength, 1.0)
        XCTAssertFalse(trends.movingAverages.isEmpty)
    }
    
    func testCalculateMovingAverages() async throws {
        // Given: Financial data across multiple periods
        try createMultiPeriodData()
        
        // When: Calculating moving averages
        let trends = try await analyticsEngine.calculateRealTimeTrends(from: fetchAllFinancialData())
        
        // Then: Should calculate meaningful moving averages
        XCTAssertEqual(trends.movingAverages.count, 3) // 7-day, 30-day, 90-day
        XCTAssertTrue(trends.movingAverages.keys.contains("7-day"))
        XCTAssertTrue(trends.movingAverages.keys.contains("30-day"))
        XCTAssertTrue(trends.movingAverages.keys.contains("90-day"))
        
        // Verify averages are positive and reasonable
        for average in trends.movingAverages.values {
            XCTAssertGreaterThan(average, 0)
        }
    }
    
    // MARK: - Performance Tests
    
    func testAnalyticsPerformanceWithLargeDataset() async throws {
        // Given: Large financial dataset
        try createLargeFinancialDataset()
        
        let startTime = Date()
        
        // When: Running analytics on large dataset
        let _ = try await analyticsEngine.generateAdvancedReport(from: fetchAllFinancialData())
        
        let endTime = Date()
        let duration = endTime.timeIntervalSince(startTime)
        
        // Then: Should complete within reasonable time (less than 5 seconds)
        XCTAssertLessThan(duration, 5.0)
    }
    
    func testConcurrentAnalyticsOperations() async throws {
        // Given: Financial data exists
        try createComprehensiveFinancialDataset()
        let data = fetchAllFinancialData()
        
        // When: Running multiple analytics operations concurrently
        async let reportTask = analyticsEngine.generateAdvancedReport(from: data)
        async let patternsTask = analyticsEngine.analyzeSpendingPatterns(from: data)
        async let anomaliesTask = analyticsEngine.detectAnomalies(from: data)
        
        // Then: All operations should complete successfully
        let report = try await reportTask
        let patterns = try await patternsTask
        let anomalies = try await anomaliesTask
        
        XCTAssertNotNil(report)
        XCTAssertNotNil(patterns)
        XCTAssertNotNil(anomalies)
    }
    
    // MARK: - Analysis State Management Tests
    
    func testAnalyzingStateToggle() async throws {
        // Given: Financial data exists
        try createComprehensiveFinancialDataset()
        
        var stateChanges: [Bool] = []
        
        // When: Monitoring analyzing state
        analyticsEngine.$isAnalyzing
            .sink { isAnalyzing in
                stateChanges.append(isAnalyzing)
            }
            .store(in: &cancellables)
        
        let _ = try await analyticsEngine.generateAdvancedReport(from: fetchAllFinancialData())
        
        // Then: Should toggle analyzing state
        XCTAssertTrue(stateChanges.contains(false)) // Initial state
        XCTAssertTrue(stateChanges.contains(true))  // During analysis
        XCTAssertFalse(analyticsEngine.isAnalyzing) // Final state
    }
    
    func testLastAnalysisDateUpdate() async throws {
        // Given: No previous analysis
        XCTAssertNil(analyticsEngine.lastAnalysisDate)
        
        // When: Running analysis
        try createComprehensiveFinancialDataset()
        let _ = try await analyticsEngine.generateAdvancedReport(from: fetchAllFinancialData())
        
        // Then: Should update last analysis date
        XCTAssertNotNil(analyticsEngine.lastAnalysisDate)
        XCTAssertLessThan(abs(analyticsEngine.lastAnalysisDate!.timeIntervalSinceNow), 1.0) // Recent
    }
    
    // MARK: - Helper Methods
    
    private func fetchAllFinancialData() -> [FinancialData] {
        let request: NSFetchRequest<FinancialData> = FinancialData.fetchRequest()
        do {
            return try testContext.fetch(request)
        } catch {
            XCTFail("Failed to fetch financial data: \(error)")
            return []
        }
    }
    
    private func createComprehensiveFinancialDataset() throws {
        let categories = ["Office Supplies", "Software", "Travel", "Meals", "Equipment"]
        let amounts = [150.0, 299.99, 1250.0, 85.50, 2500.0]
        let colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FECA57"]
        
        for (index, categoryName) in categories.enumerated() {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = categoryName
            category.colorHex = colors[index]
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "\(categoryName.lowercased())_\(index).pdf"
            document.category = category
            document.dateCreated = Date()
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "COMP\(index + 1)"
            financialData.vendorName = "\(categoryName) Vendor"
            financialData.totalAmount = NSDecimalNumber(value: amounts[index])
            financialData.currency = "USD"
            financialData.invoiceDate = Date()
            financialData.document = document
        }
        
        try testContext.save()
    }
    
    private func createSeasonalFinancialData() throws {
        let quarters = [(1, "Q1"), (4, "Q2"), (7, "Q3"), (10, "Q4")]
        let amounts = [800.0, 1200.0, 950.0, 1100.0] // Seasonal variation
        
        for (index, (month, quarter)) in quarters.enumerated() {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = "Seasonal \(quarter)"
            category.colorHex = "#FF6B6B"
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "seasonal_\(quarter).pdf"
            document.category = category
            
            let quarterDate = Calendar.current.date(from: DateComponents(year: 2025, month: month, day: 15)) ?? Date()
            document.dateCreated = quarterDate
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "SEAS\(index + 1)"
            financialData.vendorName = "Seasonal Vendor \(quarter)"
            financialData.totalAmount = NSDecimalNumber(value: amounts[index])
            financialData.currency = "USD"
            financialData.invoiceDate = quarterDate
            financialData.document = document
        }
        
        try testContext.save()
    }
    
    private func createDataWithAnomalies() throws {
        // Normal transactions
        for i in 1...10 {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = "Normal Category"
            category.colorHex = "#4ECDC4"
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "normal_\(i).pdf"
            document.category = category
            document.dateCreated = Date()
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "NORM\(i)"
            financialData.vendorName = "Normal Vendor \(i)"
            financialData.totalAmount = NSDecimalNumber(value: Double.random(in: 100...300)) // Normal range
            financialData.currency = "USD"
            financialData.invoiceDate = Date()
            financialData.document = document
        }
        
        // Anomalous transaction (unusually high amount)
        let anomalyCategory = Category(context: testContext)
        anomalyCategory.id = UUID()
        anomalyCategory.name = "Anomaly Category"
        anomalyCategory.colorHex = "#E74C3C"
        anomalyCategory.isActive = true
        
        let anomalyDocument = Document(context: testContext)
        anomalyDocument.id = UUID()
        anomalyDocument.fileName = "anomaly.pdf"
        anomalyDocument.category = anomalyCategory
        anomalyDocument.dateCreated = Date()
        
        let anomalyData = FinancialData(context: testContext)
        anomalyData.id = UUID()
        anomalyData.invoiceNumber = "ANOM1"
        anomalyData.vendorName = "Anomaly Vendor"
        anomalyData.totalAmount = NSDecimalNumber(value: 5000.0) // Unusually high
        anomalyData.currency = "USD"
        anomalyData.invoiceDate = Date()
        anomalyData.document = anomalyDocument
        
        try testContext.save()
    }
    
    private func createYearOverYearGrowthData() throws {
        let calendar = Calendar.current
        let currentYear = calendar.component(.year, from: Date())
        let lastYear = currentYear - 1
        
        // Last year data (lower amounts)
        let lastYearCategory = Category(context: testContext)
        lastYearCategory.id = UUID()
        lastYearCategory.name = "Last Year Category"
        lastYearCategory.colorHex = "#95A5A6"
        lastYearCategory.isActive = true
        
        let lastYearDoc = Document(context: testContext)
        lastYearDoc.id = UUID()
        lastYearDoc.fileName = "last_year.pdf"
        lastYearDoc.category = lastYearCategory
        lastYearDoc.dateCreated = calendar.date(from: DateComponents(year: lastYear, month: 6, day: 15)) ?? Date()
        
        let lastYearData = FinancialData(context: testContext)
        lastYearData.id = UUID()
        lastYearData.invoiceNumber = "LAST1"
        lastYearData.vendorName = "Last Year Vendor"
        lastYearData.totalAmount = NSDecimalNumber(value: 1000.0)
        lastYearData.currency = "USD"
        lastYearData.invoiceDate = lastYearDoc.dateCreated
        lastYearData.document = lastYearDoc
        
        // Current year data (higher amounts for growth)
        let currentYearCategory = Category(context: testContext)
        currentYearCategory.id = UUID()
        currentYearCategory.name = "Current Year Category"
        currentYearCategory.colorHex = "#27AE60"
        currentYearCategory.isActive = true
        
        let currentYearDoc = Document(context: testContext)
        currentYearDoc.id = UUID()
        currentYearDoc.fileName = "current_year.pdf"
        currentYearDoc.category = currentYearCategory
        currentYearDoc.dateCreated = Date()
        
        let currentYearData = FinancialData(context: testContext)
        currentYearData.id = UUID()
        currentYearData.invoiceNumber = "CURR1"
        currentYearData.vendorName = "Current Year Vendor"
        currentYearData.totalAmount = NSDecimalNumber(value: 1200.0) // 20% growth
        currentYearData.currency = "USD"
        currentYearData.invoiceDate = Date()
        currentYearData.document = currentYearDoc
        
        try testContext.save()
    }
    
    private func createSingleCategoryData() throws {
        let category = Category(context: testContext)
        category.id = UUID()
        category.name = "Single Category"
        category.colorHex = "#3498DB"
        category.isActive = true
        
        let document = Document(context: testContext)
        document.id = UUID()
        document.fileName = "single.pdf"
        document.category = category
        document.dateCreated = Date()
        
        let financialData = FinancialData(context: testContext)
        financialData.id = UUID()
        financialData.invoiceNumber = "SINGLE1"
        financialData.vendorName = "Single Vendor"
        financialData.totalAmount = NSDecimalNumber(value: 500.0)
        financialData.currency = "USD"
        financialData.invoiceDate = Date()
        financialData.document = document
        
        try testContext.save()
    }
    
    private func createDataWithFrequencyAnomalies() throws {
        let category = Category(context: testContext)
        category.id = UUID()
        category.name = "Frequency Category"
        category.colorHex = "#9B59B6"
        category.isActive = true
        
        // Normal frequency (daily for 10 days)
        for i in 1...10 {
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "frequency_\(i).pdf"
            document.category = category
            document.dateCreated = Calendar.current.date(byAdding: .day, value: -i, to: Date()) ?? Date()
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "FREQ\(i)"
            financialData.vendorName = "Frequency Vendor"
            financialData.totalAmount = NSDecimalNumber(value: 200.0)
            financialData.currency = "USD"
            financialData.invoiceDate = document.dateCreated
            financialData.document = document
        }
        
        // Unusual frequency (5 transactions in one day)
        let today = Date()
        for i in 11...15 {
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "frequent_\(i).pdf"
            document.category = category
            document.dateCreated = today
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "FREQ\(i)"
            financialData.vendorName = "Frequent Vendor"
            financialData.totalAmount = NSDecimalNumber(value: 200.0)
            financialData.currency = "USD"
            financialData.invoiceDate = today
            financialData.document = document
        }
        
        try testContext.save()
    }
    
    private func createNormalFinancialData() throws {
        let amounts = [150.0, 200.0, 175.0, 225.0, 190.0] // Normal, consistent amounts
        
        for i in 0..<amounts.count {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = "Normal Category \(i + 1)"
            category.colorHex = "#34495E"
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "normal_\(i + 1).pdf"
            document.category = category
            document.dateCreated = Calendar.current.date(byAdding: .day, value: -i-1, to: Date()) ?? Date()
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "NORM\(i + 1)"
            financialData.vendorName = "Normal Vendor \(i + 1)"
            financialData.totalAmount = NSDecimalNumber(value: amounts[i])
            financialData.currency = "USD"
            financialData.invoiceDate = document.dateCreated
            financialData.document = document
        }
        
        try testContext.save()
    }
    
    private func createTimeSeriesData() throws {
        let amounts = [100.0, 110.0, 120.0, 115.0, 125.0, 130.0, 140.0] // Trending upward
        
        for i in 0..<amounts.count {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = "Time Series Category"
            category.colorHex = "#E67E22"
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "timeseries_\(i + 1).pdf"
            document.category = category
            document.dateCreated = Calendar.current.date(byAdding: .day, value: -i*7, to: Date()) ?? Date() // Weekly data
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "TIME\(i + 1)"
            financialData.vendorName = "Time Series Vendor"
            financialData.totalAmount = NSDecimalNumber(value: amounts[i])
            financialData.currency = "USD"
            financialData.invoiceDate = document.dateCreated
            financialData.document = document
        }
        
        try testContext.save()
    }
    
    private func createMultiPeriodData() throws {
        let periods = [7, 15, 30, 45, 60, 90] // Days ago
        let amounts = [200.0, 210.0, 220.0, 215.0, 230.0, 240.0]
        
        for i in 0..<periods.count {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = "Multi Period Category"
            category.colorHex = "#16A085"
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "multiperiod_\(i + 1).pdf"
            document.category = category
            document.dateCreated = Calendar.current.date(byAdding: .day, value: -periods[i], to: Date()) ?? Date()
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "MULTI\(i + 1)"
            financialData.vendorName = "Multi Period Vendor"
            financialData.totalAmount = NSDecimalNumber(value: amounts[i])
            financialData.currency = "USD"
            financialData.invoiceDate = document.dateCreated
            financialData.document = document
        }
        
        try testContext.save()
    }
    
    private func createLargeFinancialDataset() throws {
        // Create 100 transactions for performance testing
        for i in 1...100 {
            let category = Category(context: testContext)
            category.id = UUID()
            category.name = "Category \(i % 10 + 1)" // 10 different categories
            category.colorHex = "#3498DB"
            category.isActive = true
            
            let document = Document(context: testContext)
            document.id = UUID()
            document.fileName = "large_dataset_\(i).pdf"
            document.category = category
            document.dateCreated = Calendar.current.date(byAdding: .day, value: -i, to: Date()) ?? Date()
            
            let financialData = FinancialData(context: testContext)
            financialData.id = UUID()
            financialData.invoiceNumber = "LARGE\(i)"
            financialData.vendorName = "Large Dataset Vendor \(i)"
            financialData.totalAmount = NSDecimalNumber(value: Double.random(in: 50...500))
            financialData.currency = "USD"
            financialData.invoiceDate = document.dateCreated
            financialData.document = document
        }
        
        try testContext.save()
    }
}

// MARK: - Test-Specific Supporting Types

extension AdvancedFinancialAnalyticsEngineTests {
    
    // RealTimeTrendAnalysis is now defined in the main file
}