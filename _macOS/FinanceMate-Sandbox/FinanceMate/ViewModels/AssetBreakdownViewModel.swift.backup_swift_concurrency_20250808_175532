//
// AssetBreakdownViewModel.swift
// FinanceMate
//
// Purpose: Asset breakdown business logic and state management using MVVM architecture
// Issues & Complexity Summary: ObservableObject with Core Data integration and asset categorization logic
// Key Complexity Drivers:
//   - Logic Scope (Est. LoC): ~300
//   - Core Algorithm Complexity: Medium-High (asset grouping, calculations)
//   - Dependencies: 4 (SwiftUI, Core Data, Combine, AssetBreakdownService)
//   - State Management Complexity: Medium-High (asset categories, filtering)
//   - Novelty/Uncertainty Factor: Low
// AI Pre-Task Self-Assessment: 85%
// Problem Estimate: 88%
// Initial Code Complexity Estimate: 85%
// Final Code Complexity: TBD
// Overall Result Score: TBD
// Key Variances/Learnings: TDD approach for asset breakdown MVVM testing patterns
// Last Updated: 2025-08-02

import Combine
import CoreData
import Foundation
import SwiftUI

/// Asset Breakdown ViewModel implementing MVVM architecture for asset categorization display
///
/// This ViewModel manages the business logic and state for the asset breakdown view,
/// providing real-time asset data aggregation and categorization with interactive features.
///
/// Key Responsibilities:
/// - Asset data categorization and calculations
/// - Loading state management and error handling
/// - Asset filtering and sorting operations
/// - CRUD operations for asset management
/// - Core Data integration with reactive updates
@MainActor
class AssetBreakdownViewModel: ObservableObject {

    // MARK: - Published Properties

    /// Assets grouped by category for breakdown visualization
    @Published var assetsByCategory: [Asset.AssetType: [Asset]] = [:]

    /// Total value of all assets combined
    @Published var totalAssetValue: Double = 0.0

    /// Category totals for quick access
    @Published var categoryTotals: [Asset.AssetType: Double] = [:]

    /// Category percentages for pie chart display
    @Published var categoryPercentages: [Asset.AssetType: Double] = [:]

    /// Loading state for UI feedback during data operations
    @Published var isLoading: Bool = false

    /// Error message for user display when operations fail
    @Published var errorMessage: String?

    /// Selected category for filtering (nil = show all)
    @Published var selectedCategory: Asset.AssetType?

    /// Current sort order for asset display
    @Published var sortOrder: AssetSortOrder = .valueDescending

    /// Filtered assets based on selected category
    @Published var filteredAssets: [Asset] = []

    // MARK: - Computed Properties

    /// Determines if the asset breakdown is in an empty state
    var isEmpty: Bool {
        assetsByCategory.isEmpty
    }

    /// Formatted total asset value for display
    var formattedTotalAssetValue: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale(identifier: "en_AU") // Australian locale
        formatter.currencyCode = "AUD"
        return formatter.string(from: NSNumber(value: totalAssetValue)) ?? "A$0.00"
    }

    /// Asset count description for UI display
    var assetCountDescription: String {
        let totalAssets = assetsByCategory.values.flatMap { $0 }.count
        switch totalAssets {
        case 0:
            return "No assets yet"
        case 1:
            return "1 asset"
        default:
            return "\(totalAssets) assets"
        }
    }

    /// Selected financial entity for asset filtering
    var entity: FinancialEntity?

    // MARK: - Private Properties

    private var context: NSManagedObjectContext
    private var cancellables = Set<AnyCancellable>()
    private var assetBreakdownService: AssetBreakdownService

    // MARK: - Initialization

    /// Initialize AssetBreakdownViewModel with Core Data context and optional entity
    /// - Parameters:
    ///   - context: NSManagedObjectContext for data operations
    ///   - entity: Optional FinancialEntity to filter assets
    init(context: NSManagedObjectContext, entity: FinancialEntity? = nil) {
        self.context = context
        self.entity = entity
        self.assetBreakdownService = AssetBreakdownService(context: context)
        setupNotificationObservers()
    }

    /// Convenience initializer for @StateObject usage without immediate context
    /// Context must be set via setPersistenceContext before calling data methods
    convenience init() {
        // Use preview context as fallback, but this should be replaced
        self.init(context: PersistenceController.preview.container.viewContext)
    }

    // MARK: - Core Data Context Management

    /// Set the persistence context for the ViewModel
    /// - Parameter context: NSManagedObjectContext to use for operations
    func setPersistenceContext(_ context: NSManagedObjectContext) {
        self.context = context
        self.assetBreakdownService = AssetBreakdownService(context: context)
        setupNotificationObservers()
    }

    /// Set the financial entity for asset filtering
    /// - Parameter entity: FinancialEntity to filter assets (nil for all assets)
    func setEntity(_ entity: FinancialEntity?) {
        self.entity = entity
    }

    // MARK: - Asset Data Management

    /// Fetch and calculate asset breakdown data
    func fetchAssetBreakdown() {
        Task {
            await performAsyncDataFetch()
        }
    }

    /// Perform asynchronous asset breakdown data fetch
    private func performAsyncDataFetch() async {
        isLoading = true
        errorMessage = nil

        do {
            let breakdown = await assetBreakdownService.getAssetBreakdown(for: entity)
            
            await MainActor.run {
                self.assetsByCategory = breakdown.assetsByCategory
                self.categoryTotals = breakdown.categoryTotals
                self.categoryPercentages = breakdown.categoryPercentages
                self.totalAssetValue = breakdown.totalAssetValue
                self.updateFilteredAssets()
                self.isLoading = false
            }
            
        } catch {
            await MainActor.run {
                self.errorMessage = "Failed to load asset breakdown: \(error.localizedDescription)"
                self.isLoading = false
            }
        }
    }

    // MARK: - Asset Category Operations

    /// Get total value for a specific asset category
    /// - Parameter type: Asset type to get total for
    /// - Returns: Total value for the category
    func getCategoryTotal(_ type: Asset.AssetType) -> Double {
        return categoryTotals[type] ?? 0.0
    }

    /// Get percentage allocation for a specific asset category
    /// - Parameter type: Asset type to get percentage for
    /// - Returns: Percentage allocation for the category
    func getCategoryPercentage(_ type: Asset.AssetType) -> Double {
        return categoryPercentages[type] ?? 0.0
    }

    /// Format currency value in Australian dollars
    /// - Parameter amount: Amount to format
    /// - Returns: Formatted currency string
    func formatCurrency(_ amount: Double) -> String {
        return assetBreakdownService.formatCurrency(amount)
    }

    // MARK: - Asset Filtering and Sorting

    /// Filter assets by specific type
    /// - Parameter type: Asset type to filter by (nil for all)
    func filterAssets(by type: Asset.AssetType?) {
        selectedCategory = type
        updateFilteredAssets()
    }

    /// Sort assets by specified criteria
    /// - Parameter order: Sort order to apply
    func sortAssets(by order: AssetSortOrder) {
        sortOrder = order
        Task {
            let sortedAssets = await assetBreakdownService.getSortedAssets(by: order, entity: entity)
            await MainActor.run {
                // Update the assetsByCategory with sorted data
                var newAssetsByCategory: [Asset.AssetType: [Asset]] = [:]
                for asset in sortedAssets {
                    let type = asset.type
                    if newAssetsByCategory[type] == nil {
                        newAssetsByCategory[type] = []
                    }
                    newAssetsByCategory[type]?.append(asset)
                }
                self.assetsByCategory = newAssetsByCategory
                self.updateFilteredAssets()
            }
        }
    }

    /// Update filtered assets based on selected category
    private func updateFilteredAssets() {
        if let selectedCategory = selectedCategory {
            filteredAssets = assetsByCategory[selectedCategory] ?? []
        } else {
            filteredAssets = assetsByCategory.values.flatMap { $0 }
        }
    }

    // MARK: - Asset CRUD Operations

    /// Add new asset to the selected entity
    /// - Parameters:
    ///   - name: Asset name
    ///   - type: Asset type
    ///   - currentValue: Current market value
    ///   - purchasePrice: Optional purchase price
    ///   - purchaseDate: Optional purchase date
    func addAsset(
        name: String,
        type: Asset.AssetType,
        currentValue: Double,
        purchasePrice: Double? = nil,
        purchaseDate: Date? = nil
    ) {
        guard let entity = entity else {
            errorMessage = "Financial entity required to add asset"
            return
        }

        Task {
            let result = await assetBreakdownService.addAsset(
                name: name,
                type: type,
                currentValue: currentValue,
                purchasePrice: purchasePrice,
                purchaseDate: purchaseDate,
                to: entity
            )

            await MainActor.run {
                if result != nil {
                    // Refresh data after successful addition
                    self.fetchAssetBreakdown()
                } else {
                    self.errorMessage = "Failed to add asset"
                }
            }
        }
    }

    /// Update existing asset value
    /// - Parameters:
    ///   - asset: Asset to update
    ///   - newValue: New current value
    func updateAsset(_ asset: Asset, newValue: Double) {
        Task {
            let success = await assetBreakdownService.updateAsset(asset, newValue: newValue)

            await MainActor.run {
                if success {
                    // Refresh data after successful update
                    self.fetchAssetBreakdown()
                } else {
                    self.errorMessage = "Failed to update asset"
                }
            }
        }
    }

    /// Delete existing asset
    /// - Parameter asset: Asset to delete
    func deleteAsset(_ asset: Asset) {
        Task {
            let success = await assetBreakdownService.deleteAsset(asset)

            await MainActor.run {
                if success {
                    // Refresh data after successful deletion
                    self.fetchAssetBreakdown()
                } else {
                    self.errorMessage = "Failed to delete asset"
                }
            }
        }
    }

    // MARK: - Formatting Helpers (Real Data)

    /// Formatted total asset value with AUD currency
    var formattedTotalValue: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = "AUD"
        formatter.locale = Locale(identifier: "en_AU")
        return formatter.string(from: NSNumber(value: totalAssetValue)) ?? "$0.00"
    }
    
    /// Formatted category total with AUD currency
    /// - Parameter assetType: Asset type to format total for
    /// - Returns: Formatted currency string
    func formattedCategoryTotal(for assetType: Asset.AssetType) -> String {
        let total = categoryTotals[assetType] ?? 0.0
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = "AUD"
        formatter.locale = Locale(identifier: "en_AU")
        return formatter.string(from: NSNumber(value: total)) ?? "$0.00"
    }

    // MARK: - Error Handling

    /// Clear current error message
    func clearError() {
        errorMessage = nil
    }

    /// Test method for invalid entity error (used by tests)
    func testInvalidEntityError() {
        errorMessage = "Financial entity required for asset operations"
    }

    // MARK: - Notification Observers

    /// Setup Core Data change notification observers
    private func setupNotificationObservers() {
        // Listen for Core Data context changes
        NotificationCenter.default.publisher(for: .NSManagedObjectContextDidSave)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.fetchAssetBreakdown()
            }
            .store(in: &cancellables)
    }

    // MARK: - Cleanup

    deinit {
        cancellables.removeAll()
    }
}